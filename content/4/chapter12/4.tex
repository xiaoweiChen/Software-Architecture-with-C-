
As mentioned earlier in the chapter, the common characteristic of web services is that they are based on standard web technologies. Most of the time, this will mean the Hypertext Transfer Protocol (HTTP) and this is the technology we will focus on. Although it is possible to implement web services based on different protocols, such services are extremely rare and therefore out of our scope.

\subsubsubsection{12.4.1\hspace{0.2cm}Tools for debugging web services}

One of the major benefits of using HTTP as transport is the wide availability of tools. For the most part, testing and debugging a web service may be performed using nothing more than a web browser. Apart from that, there are a lot of additional programs that may be helpful in automation. These include the following:

\begin{itemize}
\item 
The standard Unix file downloader wget

\item 
The modern HTTP client curl

\item 
Popular open source libraries such as libcurl, curlpp, C++ REST SDK, cpr (C++ HTTP requests library), and NFHTTP

\item 
Testing frameworks such as Selenium or Robot Framework

\item 
Browser extensions such as Boomerang

\item 
Standalone solutions such as Postman and Postwoman

\item 
Dedicated testing software including SoapUI and Katalon Studio
\end{itemize}

HTTP-based web services work by returning an HTTP response to an HTTP request that uses appropriate HTTP verbs (such as GET, POST, and PUT). The semantics of how the request and the response should look and what data they should convey differs from implementation to implementation.

Most implementations fall into one of two categories: XML-based web services and JSONbased web services. JSON-based web services are currently displacing XML-based ones, but it is still common to find services that use XML formats.

For dealing with data encoded with either JSON or XML, additional tools such as xmllint, xmlstarlet, jq, and libxml2 may be required.

\subsubsubsection{12.4.2\hspace{0.2cm}XML-based web services}

The first web services that gained traction were primarily based on XML. XML or eXtensible Markup Language was at the time the interchange format of choice in distributed computing and in the web environment. There were several different approaches to designing services with an XML payload.

It is possible that you may want to interact with existing XML-based web services that are developed either internally within your organization or externally. However, we advise you to implement new web services using more lightweight methods, such as JSON-based web services, RESTful web services, or gRPC.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{XML-RPC}

One of the first standards that emerged was called XML-RPC. The idea behind the project was to provide an RPC technology that would compete with the then prevalent Common Object Model (COM), and CORBA. The aim was to use HTTP as a transport protocol and make the format human-readable and human-writable as well as parsable to machines. To achieve that, XML was chosen as the data encoding format.

When using XML-RPC, the client that wants to perform a remote procedure call sends an HTTP request to the server. The request may have multiple parameters. The server answers with a single response. The XML-RPC protocol defines several data types for parameters and results.

Although SOAP features similar data types, it uses XML schema definitions, which make the messages much less readable than the ones in XML-RPC.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Relationship to SOAP}

Since XML-RPC is no longer actively maintained, there aren't any modern C++ implementations for the standard. If you want to interact with XML-RPC web services from modern code, the best way may be to use the gSOAP toolkit that supports XML-RPC and other XML web service standards.

The main criticism of XML-RPC was that it didn't give much value over sending plain XML requests and responses while making the messages significantly larger.

As the standard evolved, it became SOAP. As SOAP it formed the basis for the W3C web services stack of protocols.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{SOAP}

The original abbreviation of SOAP stood for Simple Object Access Protocol. The abbreviation was dropped in version 1.2 of the standard. It's an evolution of the XML-RPC standard.

SOAP consists of three parts:

\begin{itemize}
\item 
The SOAP envelope, defining the message's structure and processing rules

\item 
The SOAP header rules defining application-specific data types (optional)

\item 
The SOAP body, which carries remote procedure calls and responses
\end{itemize}

Here's an example SOAP message using HTTP as transport:

\begin{tcblisting}{commandshell={}}
POST /FindMerchants HTTP/1.1
Host: www.domifair.org
Content-Type: application/soap+xml; charset=utf-8
Content-Length: 345
SOAPAction: "http://www.w3.org/2003/05/soap-envelope"

<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
  <soap:Header>
  </soap:Header>
  <soap:Body xmlns:m="https://www.domifair.org">
    <m:FindMerchants>
      <m:Lat>54.350989</m:Lat>
      <m:Long>18.6548168</m:Long>
      <m:Distance>200</m:Distance>
    </m:FindMerchants>
  </soap:Body>
</soap:Envelope>
\end{tcblisting}

The example uses standard HTTP headers and the POST method to call a remote procedure. One header that is unique to SOAP is the SOAPAction. It points to a URI identifying the intent of the action. It is up to the clients to decide how to interpret this URI.

soap:Header is optional so we leave it empty. Together with soap:Body, it is contained within soap:Envelope. The main procedure call takes place within soap:Body. We introduce our own XML namespace that is specific to the Dominican Fair application. The namespace points to the root of our domain. The procedure we call is FindMerchants and we provide three arguments: latitude, longtitude, and distance.

As SOAP was designed to be extensible, transport-neutral, and independent of the programming model, it also led to the creation of other accompanying standards. This means it is usually necessary to learn all the related standards and protocols before using SOAP.

This is not a problem if your application makes extensive use of XML and your development team is familiar with all the terms and specifications. However, if all you want is to expose an API for a third party, a much easier approach would be to build a REST API as it is much easier to learn for both producers and consumers.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{WSDL}

Web Services Description Language (WSDL) provides a machine-readable description of how services can be called and how messages should be formed. Like the other W3C web services standards, it is encoded in XML.

It is often used with SOAP to define interfaces that the web service offers and how they may be used.

Once you define your API in WSDL, you may (and should!) use automated tooling to help you create code out of it. For C++, one framework with such tools is gSOAP. It comes with a tool named wsdl2h, which will generate a header file out of the definition. You can then use another tool, soapcpp2, to generate bindings from the interface definition to your implementation.

Unfortunately, due to the verbosity of the messages, the size and bandwidth requirements for SOAP services are generally huge. If this is not an issue, then SOAP can have its uses. It allows for both synchronous and asynchronous calls, as well as stateful and stateless operations. If you require rigid, formal means of communication, SOAP can provide them. Just make sure to use version 1.2 of the protocol due to the many improvements it introduces. One of them is the enhanced security of the services. Another is the improved definition of services themselves, which aids interoperability, or the ability to formally define the means of transportation (allowing for the usage of message queues), to name just a few.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{UDDI}

The next step after documenting the web service interfaces is service discovery, which allows applications to find and connect to the services implemented by other parties.

Universal Description, Discovery, and Integration (UDDI) is a registry for WSDL files that may be searched manually or automatically. As with the other technologies discussed in this section, UDDI uses an XML format.

UDDI registry may be queried with SOAP messages for automated service discovery. Even though UDDI provided the logical extensions of WSDL, its adoption in the open was disappointing. It is still possible to find UDDI systems used internally by companies.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{SOAP libraries}

Two of the most popular libraries for SOAP are Apache Axis and gSOAP.

Apache Axis is suitable for implementing both SOAP (including WSDL) and REST web services. It's worth noting that the library hasn't seen a new release for over a decade.

gSOAP is a toolkit that allows for creating and interacting with XML-based web services with a focus on SOAP. It handles data binding, SOAP and WSDL support, JSON and RSS parsing, UDDI APIs, and several other related web services standards. Although it doesn't use modern C++ features, it is still actively maintained.

\subsubsubsection{12.4.3\hspace{0.2cm}JSON-based web services}

JSON stands for JavaScript Object Notation. Contrary to what the name suggests, it is not limited to JavaScript. It is language-independent. Parsers and serializers for JSON exist in most programming languages. JSON is much more compact than XML.

Its syntax is derived from JavaScript as it was based on a JavaScript subset.

Supported data types for JSON are the following:

\begin{itemize}
\item 
Number: The exact format may vary between implementations; defaults to the double-precision floating-point in JavaScript.

\item 
String: Unicode-encoded.

\item 
Boolean: Using true and false values.

\item 
Array: May be empty.

\item 
Object: A map with key-value pairs.

\item 
null: Representing an empty value.
\end{itemize}

The Packer configuration presented in Chapter 9, Continuous Integration/Continuous Deployment, is an example of a JSON document:

\begin{tcblisting}{commandshell={}}
{
  "variables": {
    "aws_access_key": "",
    "aws_secret_key": ""
  },
  "builders": [{
    "type": "amazon-ebs",
    "access_key": "{{user `aws_access_key`}}",
    "secret_key": "{{user `aws_secret_key`}}",
    "region": "eu-central-1",
    "source_ami": "ami-5900cc36",
    "instance_type": "t2.micro",
    "ssh_username": "admin",
    "ami_name": "Project's Base Image {{timestamp}}"
  }],
  "provisioners": [{
    "type": "ansible",
    "playbook_file": "./provision.yml",
    "user": "admin",
    "host_alias": "baseimage"
  }],
  "post-processors": [{
    "type": "manifest",
    "output": "manifest.json",
    "strip_path": true
  }]
}
\end{tcblisting}

One of the standards using JSON as a format is the JSON-RPC protocol.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{JSON-RPC}

JSON-RPC is a JSON-encoded remote procedure call protocol similar to XML-RPC and SOAP. Unlike its XML predecessor, it requires little overhead. It is also very simple while maintaining the human-readability of XML-RPC.

This is how our previous example expressed in a SOAP call will look with JSON-RPC 2.0:

\begin{tcblisting}{commandshell={}}
{
  "jsonrpc": "2.0",
  "method": "FindMerchants",
  "params": {
    "lat": "54.350989",
    "long": "18.6548168",
    "distance": 200
  },
  "id": 1
}
\end{tcblisting}

This JSON document still requires proper HTTP headers, but even with the headers, it is still considerably smaller than the XML counterpart. The only metadata present is the file with the JSON-RPC version and the request ID. The method and params fields are pretty much self-explanatory. The same can't always be said about SOAP.

Even though the protocol is lightweight, easy to implement, and easy to use, it hasn't seen widespread adoption when compared to both SOAP and REST web services. It was released much later than SOAP and around the same time that REST services started to get popular. While REST quickly rose to success (possibly due to its flexibility), JSON-RPC failed to get similar traction.

Two useful implementations for C++ are libjson-rpc-cpp and json-rpc-cxx. json-rpc-cxx is a modern reimplementation of the previous library.

\subsubsubsection{12.4.4\hspace{0.2cm}REpresentational State Transfer (REST)}

An alternative approach to web services is REpresentional State Transfer (REST). Services that conform to this architectural style are often called RESTful services. The main difference between REST and SOAP or JSON-RPC is that REST is based almost entirely on HTTP and URI semantics.

REST is an architectural style defining a set of constraints when implementing web services. Services that conform to this style are called RESTful. These constraints are as follows:

\begin{itemize}
\item 
Must use a client-server model.

\item 
Statelessness (neither the client nor the server needs to store the state related to their communication).

\item 
Cacheability (responses should be defined as cacheable or non-cacheable to benefit from standard web caching to improve scalability and performance).

\item 
Layered system (proxies and load balancers should by no means affect the communication between the client and server).
\end{itemize}

REST uses HTTP as the transport protocol with URIs representing resources and HTTP verbs that manipulate the resources or invoke operations. There is no standard regarding how each HTTP method should behave, but the semantics most often agreed on are the following:

\begin{itemize}
\item 
POST – Create a new resource.

\item 
GET – Retrieve an existing resource.

\item 
PATCH – Update an existing resource.

\item 
DELETE – Delete an existing resource.

\item 
PUT – Replace an existing resource.
\end{itemize}

Due to reliance on web standards, RESTful web services can reuse existing components such as proxies, load balancers, and the cache. Thanks to the low overhead, such services are also very performant and efficient.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Description languages}

Just like with XML-based web services, RESTful services can be described in both a machine and human-readable way. There are a few competing standards available, with OpenAPI being the most popular.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{OpenAPI}

OpenAPI is a specification overseen by the OpenAPI Initiative, part of the Linux Foundation. It used to be known as the Swagger Specification as it used to be a part of the Swagger framework.

The specification is language agnostic. It uses JSON or YAML input to generate documentation of methods, parameters, and models. This way, using OpenAPI helps to keep the documentation and source code up to date.

There is a good selection of tools compatible with OpenAPI, such as code generators, editors, user interfaces, and mock servers. The OpenAPI generator can generate code for C++ using either cpp-restsdk or Qt 5 for client implementation. It can also generate server code using Pistache, Restbed, or Qt 5 QHTTPEngine. There's also a convenient OpenAPI editor available online: https://editor.swagger.io/.

An API documented with OpenAPI would look like the following:

\begin{tcblisting}{commandshell={}}
{
  "openapi": "3.0.0",
  "info": {
    "title": "Items API overview",
    "version": "2.0.0"
  },
  "paths": {
    "/item/{itemId}": {
      "get": {
        "operationId": "getItem",
        "summary": "get item details",
        "parameters": [
          "name": "itemId",
          "description": "Item ID",
          "required": true,
          "schema": {
            "type": "string"
        }
      ],
      "responses": {
        "200": {
          "description": "200 response",
            "content": {
              "application/json": {
                "example": {
                  "itemId": 8,
                  "name", "Kürtőskalács",
                  "locationId": 5
                }
              }
            }
          }
        }
      }
    }
  }
}
\end{tcblisting}

The first two fields (openapi and info) are metadata describing the document. The paths field contains all of the possible paths that correspond to the resources and methods of the REST interface. In the preceding example, we are only documenting a single path (/item) and a single method (GET). This method takes itemId as a required parameter. We provide a single possible response code, which is 200. A 200 response contains a body that is a JSON document itself. The value associated with the example key is the example payload of a successful response.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{RAML}

A competing specification, RAML, stands for RESTful API Modeling Language. It uses YAML for description and enables discovery, code reuse, and pattern-sharing.

The rationale behind establishing RAML was that while OpenAPI is a great tool to document existing APIs, it was not, at the time, the best way to design new APIs. Currently, the specification is being considered to become a part of the OpenAPI Initiative.

A RAML document may be converted to OpenAPI to make use of the available tooling.

Here's an example of an API documented with RAML:

\begin{tcblisting}{commandshell={}}
#%RAML 1.0

title: Items API overview
version: 2.0.0

annotationTypes:
  oas-summary:
    type: string
    allowedTargets: Method

/item:
  get:
    displayName: getItem
    queryParameters:
      itemId:
        type: string
    responses:
     '200':
       body:
         application/json:
           example: |
             {
               "itemId": 8,
               "name", "Kürtőskalács",
               "locationId": 5
             }
       description: 200 response
    (oas-summary): get item details
\end{tcblisting}

This example describes the same interface documented previously with OpenAPI. When serialized in YAML, both OpenAPI 3.0 and RAML 2.0 look very similar. The main difference is that OpenAPI 3.0 requires the use of JSON schema for documenting structures. With RAML 2.0, you can reuse the existing XML Schema Definition (XSD), which makes it easier to migrate from XML-based web services or to include external resources.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{API Blueprint}

API Blueprint presents a different approach to the preceding two specifications. Instead of relying on either JSON or YAML, it uses Markdown to document data structures and endpoints.

Its approach is similar to the test-driven development methodology, as it encourages designing contracts before implementing features. This way, it is easier to test whether the implementation actually fulfills the contract.

Just like with RAML, it is possible to convert the API Blueprint specification to OpenAPI as well as the other way round. There is also a command-line interface and a C++ library for parsing API Blueprints, called Drafter, which you can use in your code.

An example of a simple API documented with API Blueprint looks like the following:

\begin{tcblisting}{commandshell={}}
FORMAT: 1A

# Items API overview

# /item/{itemId}

## GET

+ Response 200 (application/json)

    {
      "itemId": 8,
      "name": "Kürtőskalács",
      "locationId": 5
    }
\end{tcblisting}

In the preceding, we see that a GET method directed at the /item endpoint should result in a response code of 200. Below that is the JSON message that corresponds to the one our service will typically return.

API Blueprint allows for more natural documentation. The main disadvantage is that it is the least popular of the formats described so far. This means both the documentation and tooling are nowhere near the quality of OpenAPI.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{RSDL}

Similar to WSDL, RSDL (or RESTful Service Description Language), is an XML description for web services. It is language-independent and designed to be both humanand machine-readable.

It's much less popular than the previously presented alternatives. It is also much harder to read, especially compared to API Blueprint or RAML.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Hypermedia as the Engine of Application State}

Although providing a binary interface such as a gRPC-based one can give you great performance, in many cases, you'll still want to have the simplicity of a RESTful interface. Hypermedia as the Engine of Application State (HATEOAS) can be a useful principle to implement if you want an intuitive REST-based API.

Just as you would open a web page and navigate based on the hypermedia shown, you can write your services with HATEOAS to achieve the same thing. This promotes the decoupling of server and client code and allows a client to quickly know what requests are valid to send, which is often not the case with binary APIs. The discovery is dynamic and based on the hypermedia provided.

If you take a typical RESTful service, when executing an operation, you get JSON with data such as an object's state. With HATEOAS, aside from that, you would get a list of links (URLs) showing you the valid operations you can run on said object. The links (hypermedia) are the engine of the application. In other words, the available actions are determined by the state of the resources. While the term hypermedia may sound strange in this context, it basically means linking to the resources, including text, images, and video.

For example, if we have a REST method allowing us to add an item by using the PUT method, we could add a return parameter that links to the resource created that way. If we use JSON for serialization, this could take the following form:

\begin{tcblisting}{commandshell={}}
{
  "itemId": 8,
  "name": "Kürtőskalács",
  "locationId": 5,
  "links": [
    {
      "href": "item/8",
      "rel": "items",
      "type" : "GET"
    }
  ]
}
\end{tcblisting}

There is no universally accepted method of serializing HATEOAS hypermedia. On the one hand, it makes it easier to implement regardless of the server implementation. On the other hand, the client needs to know how to parse the response to find the relevant traversal data.

One of the benefits of HATEOAS is that it makes it possible to implement the API changes on the server side without necessarily breaking the client code. When one of the endpoints gets renamed, the new endpoint is referenced in subsequent responses, so the client is informed where to direct further requests.

The same mechanism may provide features such as paging or make it easy to discover methods available for a given object. Getting back to our item example, here's a possible response we could receive after making a GET request:

\begin{tcblisting}{commandshell={}}
{
  "itemId": 8,
  "name": "Kürtőskalács",
  "locationId": 5,
  "stock": 8,
  "links": [
    {
      "href": "item/8",
      "rel": "items",
      "type" : "GET"
    },
    {
      "href": "item/8",
      "rel": "items",
      "type" : "POST"
    },
    {
      "href": "item/8/increaseStock",
      "rel": "increaseStock",
      "type" : "POST"
    },
    {
      "href": "item/8/decreaseStock",
      "rel": "decreaseStock",
      "type" : "POST"
    }
  ]
}
\end{tcblisting}

Here, we got links to two methods responsible for modifying the stock. If the stock is no longer available, our response will look like this (note that one of the methods is no longer advertised):

\begin{tcblisting}{commandshell={}}
{
  "itemId": 8,
  "name": "Kürtőskalács",
  "locationId": 5,
  "stock": 0,
  "links": [
    {
      "href": "items/8",
      "rel": "items",
      "type" : "GET"
    },
    {
      "href": "items/8",
      "rel": "items",
      "type" : "POST"
    },
    {
      "href": "items/8/increaseStock",
      "rel": "increaseStock",
      "type" : "POST"
    }
  ]
}
\end{tcblisting}

One of the significant problems related to HATEOAS is that the two design principles seem to be at odds with each other. Adding traversable hypermedia would be much easier to consume if it were always presented in the same format. The freedom of expression here makes it harder to write clients unaware of the server's implementation.

Not all RESTful APIs can benefit from introducing this principle – by introducing HATEOAS you commit to writing clients in a specific manner so that they're able to benefit from this API style.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{REST in C++}

Microsoft's C++ REST SDK is currently one of the best ways to implement RESTful APIs in C++ applications. Also known as cpp-restsdk, it is the library that we're using in this book to illustrate various examples.

\subsubsubsection{12.4.5\hspace{0.2cm}GraphQL}

A recent alternative to REST web services is GraphQL. The QL in the name stands for Query Language. Rather than relying on the server to serialize and present the necessary data, in GraphQL clients query and manipulate the data directly. Apart from the reversal of responsibility, GraphQL also features mechanisms that make it easier to work with data. Typing, static validation, introspection, and schemas are all parts of the specification.

There are server implementations of GraphQL available for a lot of languages including C++. One of the popular implementations is cppgraphqlgen from Microsoft. There are also many tools that help with development and debugging. What's interesting is that you can use GraphQL to query the database directly thanks to products such as Hasura or PostGraphile, which add the GraphQL API on top of a Postgres database.














