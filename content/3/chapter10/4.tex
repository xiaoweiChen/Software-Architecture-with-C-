可以通过使用现代的C++结构，来减少代码中常见安全漏洞的数量，而不是使用较老的C等价代码。然而，总是有更安全的抽象也证明是脆弱的。仅仅选择更安全的实现，并认为已经尽了最大努力是不够的。大多数情况下，有一些方法可以进一步加强代码。

但是什么是加强代码？根据定义，是减少系统表面脆弱性的过程。通常，这意味着关闭不使用的功能，并着眼于更简单的系统而不是复杂的系统。这还可能使用工具来增加现有功能的健壮性。

当应用于操作系统级别时，这些工具可能意味着内核补丁、防火墙和入侵检测系统(IDS)。在应用程序级别，这可能意味着各种缓冲区溢出和下溢保护机制，使用容器和虚拟机(VM)进行特权隔离和进程隔离，或强制加密通信和存储。

本节中，我们将关注应用程序级别的一些示例，而下一节将关注操作系统级别。

\subsubsubsection{10.4.1\hspace{0.2cm}面向安全性的内存分配器}

如果非常重视保护应用程序免受堆相关的攻击，例如：堆溢出、释放后使用或双重释放，可以考虑用面向安全的版本替换标准内存分配器。以下是两个可能会引起兴趣的项目:

\begin{itemize}
\item 
FreeGuard，可在\url{https://github.com/UTSASRG/FreeGuard}获得，并在\url{https://arxiv.org/abs/1709.02746}的一篇论文中描述

\item 
GrapheneOS项目的hardened\_malloc，可在\url{https://github.com/GrapheneOS/hardened\_malloc}处获得
\end{itemize}

FreeGuard于2017年发布，自那以来除了零星的bug修复外，并没有太大的变化。另一方面，hardened\_malloc正在积极地开发。这两个分配器都设计为作为标准malloc()的替代品。可以在不修改应用程序的情况下使用它们，只需设置LD\_PRELOAD环境变量或将库添加到/etc/preload.so配置文件中。FreeGuard的目标是Linux和64位x86系统上的Clang编译器，而hardened\_malloc的目标是更广泛的兼容性，尽管目前主要支持Android的Bionic，musl和glibc。hardened\_malloc也是基于OpenBSD的alloc, OpenBSD本身就是以安全为中心的项目。

可以将所使用的集合替换为更安全的等价物，而不是替换内存分配器。SaferCPlusPlus(\url{https://duneroadrunner.github.io/SaferCPlusPlus/})项目提供了\texttt{std::vector<>}、\texttt{std::array<>}和\texttt{std::string}的替代品，这些替代品可以作为现有代码中的临时替换。该项目还包括防止未初始化使用或符号不匹配的基本类型的替代品、并发数据类型，以及指针和引用的替代品。

\subsubsubsection{10.4.2\hspace{0.2cm}自动检查}

有一些工具可以有助于确保正在构建的系统的安全性。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{编译器警告}

虽然编译器警告本身不是一种工具，但可以使用并调整编译器警告，以获得每个C++开发人员都将使用的工具——C++编译器——更好的输出。

因为编译器可以做一些比标准要求的更深入的检查，所以建议利用这种可能性。当使用GCC或Clang等编译器时，推荐的设置包括\texttt{-Wall -Wextra}标志。这将产生更多的诊断信息，并在代码没有遵循诊断时产生警告。如果希望更严格一些，还可以启用\texttt{-Werror}，它会把所有警告转换为错误，并防止编译没有通过增强诊断的代码。如果想严格遵守标准，有\texttt{-pedantic}和\texttt{-pedanticerrors}标志，它们将检查代码是否符合标准。

当使用CMake进行构建时，可以使用以下函数在编译期间启用这些标志:

\begin{lstlisting}[style=styleCMake]
add_library(customer ${SOURCES_GO_HERE})
target_include_directories(customer PUBLIC include)
target_compile_options(customer PRIVATE -Werror -Wall -Wextra)
\end{lstlisting}

这样，除非修复编译器报告的所有警告(已转换的错误)，否则编译将失败。

也可以在OWASP(\url{https://www.owasp.org/index.php/C-Based\_Toolchain\_Hardening})和Red Hat (\url{https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/})的这些文章中找到工具链的建议设置。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{静态分析}

有一类工具可以提高代码的安全性，这就是所谓的静态应用程序安全测试(SAST)工具。它们是只关注安全方面的静态分析工具。

SAST工具可以很好地集成到CI/CD流水中，它们只是读取源代码。输出通常也适用于CI/CD，因为它突出了源代码中特定位置发现的问题。另一方面，静态分析可能会忽略许多类型的问题，这些问题无法自动找到，或者仅通过静态分析无法找到。这些工具也不关心与配置相关的问题，因为配置文件没有在源代码本身中表示。

C++ SAST工具的例子包括以下开源解决方案:

\begin{itemize}
\item 
Cppcheck(\url{http://cppcheck.sourceforge.net/})，是一个通用的静态分析工具，专注于低误报数量

\item 
Flawfinder(\url{https://dwheeler.com/flawfinder/})，似乎没有积极地维护

\item 
LGTM(\url{https://lgtm.com/help/lgtm/about-lgtm})，支持几种不同的语言，具有自动分析拉请求的功能

\item 
SonarQube(\url{https://www.sonarqube.org/})，可以很好的CI/CD集成和语言覆盖，并提供了一个商业版本

\item 
Checkmarx CxSAST(\url{https://www.checkmarx.com/products/staticapplication-security-testing/})，它可以零配置和语言覆盖

\item 
CodeSonar(\url{https://www.grammatech.com/products/codesonar})，专注于深度分析和发现缺陷

\item 
Klocwork(\url{https://www.perforce.com/products/klocwork})，专注于准确性

\item 
Micro Focus Fortify(\url{https://www.microfocus.com/en-us/products/staticcode-analysis-sast/overview})，具有广泛的语言支持和集成的其他工具(由同一制造商)

\item 
Parasoft C/C++测试(\url{https://www.parasoft.com/products/ctest})，这是一个静态和动态分析、单元测试、跟踪等的(集成)解决方案

\item 
Polyspace Bug Finder来自MathWorks(\url{https://www.mathworks.com/products/polyspace-bug-finder.html})，可以与Simulink模型的集成

\item 
Veracode静态分析(\url{https://www.veracode.com/products/binarystatic-analysis-sast})，是一个用于静态分析的SaaS解决方案

\item 
白帽哨兵源(\url{https://www.whitehatsec.com/platform/staticapplication-security-testing/})，也专注于消除误报
\end{itemize}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{动态分析}

就像对源代码执行静态分析一样，对生成的二进制文件执行动态分析，名称中的“动态”是指观察代码在动作中处理的实际数据。当关注安全性时，这类工具也可以称为动态应用程序安全测试(DAST)。

与SAST相比，主要优势是可以找到许多从源代码分析角度看不到的流。当然，这也带来了一个缺点，必须运行应用程序才能执行分析。我们知道，运行应用程序可能既耗时又耗内存。

DAST工具通常专注于Web相关的漏洞，如XSS、SQL(和其他)注入，或公开的敏感信息。下一小节中，将更多地关注更通用的动态分析工具之一Valgrind。

\hspace*{\fill} \\ %插入空行
\noindent
\textit{Valgrind和应用验证器}

Valgrind is mostly known as a memory leak debugging tool. It is, in fact, an instrumentation framework that helps to build dynamic analysis tools not necessarily related to memory problems. Besides the memory error detector, the suite of tools currently consists of a thread error detector, a cache and branch prediction profiler, and a heap profiler. It's supported on various platforms on Unix-like operating systems (including Android).

Essentially, Valgrind acts as a VM, first translating the binary into a simpler form called intermediate representation. Instead of running the program on an actual processor, it gets executed under this VM so each call can be can be analyzed and validated.

If you're developing on Windows, you can use Application Verifier (AppVerifier) instead of Valgrind. AppVerifier can help you detect stability and security issues. It can monitor running applications and user-mode drivers to look for memory issues such as leaks and heap corruption, threading and locking issues, invalid use of handles, and more.

\hspace*{\fill} \\ %插入空行
\noindent
\textit{消杀工具}

Sanitizers are dynamic testing tools that are based on compile-time instrumentation of code. They can help with the overall stability and security of the system, as well as avoiding undefined behavior. At https://github.com/google/sanitizers, you can find implementations for LLVM (which Clang is based on) and GCC. They address problems with memory access, memory leaks, data races and deadlocks, uninitialized memory use,
and undefined behavior.

AddressSanitizer (ASan) protects your code against issues related to memory addressing, such as global-buffer-overflow, use-after-free, or stack-use-after-return. Even though it's one of the fastest solutions of its kind, it still slows down the process about two times. It's best to use it when running tests and doing development but turn it off in production builds. You can turn it on for your builds by adding the -fsanitize=address flag to Clang.

AddressSanitizerLeakSanitizer (LSan) integrates with ASan to find memory leaks. It is enabled by default on x86\_64 Linux and x86\_64 macOS. It requires setting an environment variable, ASAN\_OPTIONS=detect\_leaks=1. LSan performs leak detection at the end of the process. LSan can also be used as a standalone library without AddressSanitizer, but this mode is much less tested.

ThreadSanitizer (TSan), as we previously mentioned, detects problems with concurrency such as data races and deadlocks. You can enable it with the -fsanitize=thread flag to Clang.

MemorySanitizer (MSan) focuses on bugs related to access to uninitialized memory. It implements some of the features of Valgrind that we covered in the previous subsection. MSan supports 64-bit x86, ARM, PowerPC, and MIPS platforms. You can enable it with the -fsanitize=memory -fPIE -pie flag to Clang (which also turns on positionindependent executables, a concept we'll discuss later on).

Hardware-Assisted Address Sanitizer (HWASAN) is similar to the regular ASan. The main difference is the use of hardware assistance when possible. This feature is, for now, available only on 64-bit ARM architectures.

UndefinedBehaviorSanitizer (UBSan) looks for other possible causes of undefined behavior, such as integer overflow, division by zero, or improper bit shift operations. You can enable it with the -fsanitize=undefined flag to Clang.

Even though sanitizers can help you uncover many potential problems, they are only as good as the tests that you run them against. When using the sanitizers, keep in mind to keep the code coverage of your tests high because otherwise, you may get a false sense of security.

\hspace*{\fill} \\ %插入空行
\noindent
\textit{模糊测试}

A subcategory of DAST tools, fuzz-testing checks the behavior of your application when confronted with invalid, unexpected, random, or maliciously formed data. Such checks can be especially useful when used against the interfaces that cross the trust boundary (such as end user file upload forms or inputs).

Some interesting tools from this category include the following:

\begin{itemize}
\item 
Peach Fuzzer: https://www.peach.tech/products/peach-fuzzer/

\item 
PortSwigger Burp: https://portswigger.net/burp

\item 
The OWASP Zed Attack Proxy project: https://www.owasp.org/index.php/OWAS\_Zed\_Attack\_Proxy\_Project

\item 
Google's ClusterFuzz: https://github.com/google/clusterfuzz (and OSSFuzz: https://github.com/google/oss-fuzz)
\end{itemize}

\subsubsubsection{10.4.3\hspace{0.2cm}Process isolation and sandboxing}

If you want to run unverified software in your own environment, you may want to isolate it from the rest of your system. Some ways to sandbox the executed code is via VMs, containers, or micro VMs such as Firecracker (https://firecracker-microvm.github.io/) used by AWS Lambda.

This way, the crashes, leaks, and security problems of one application won't propagate to the entire system, rendering it either useless or compromised. As each process will have its own sandbox, the worst-case scenario would be the loss of only this one service.

For C and C++ code, there is also Sandboxed API (SAPI; https://github.com/google/sandboxed-api) an open source project led by Google. It allows building sandboxes not for entire processes but for libraries. It is used by Google's own Chrome and Chromium web browsers, among others.

Even though VMs and containers can be a part of the process isolation strategy, don't confuse them with microservices, which often use similar building blocks. Microservices are an architectural design pattern and they don't automatically equal better security.

















