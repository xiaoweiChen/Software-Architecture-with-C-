
本章中，提供了如何检查代码、依赖和环境的潜在威胁的信息。但请记住，遵循本章中列出的每一步并不一定能避免所有问题。我们的目的是展示一些可能的危险，以及应对的方法。因此，应该时刻注意系统的安全性，并将审计作为常规事件。

在互联网普及之前，软件作者并不太关心设计的安全性。毕竟，如果用户提供了错误的数据，最多只会让自己的机器崩溃。为了利用软件漏洞访问受保护的数据，攻击者必须获得对保存数据机器的物理访问权。

即使在设计用于网络内部的软件中，安全问题也常常事后才考虑。以HTTP协议为例，尽管它允许对某些资产进行密码保护，但所有数据都以明文传输，这意味着在同一网络上的每个人都可以窃听正在传输的数据。

现在，我们应该从设计的第一阶段就拥抱安全性，并在软件开发、操作和维护的每一个阶段都要牢记安全性。我们每天生产的大多数软件都是为了以某种方式与其他现有系统连接。

由于忽略了安全措施，不仅让自己，也让合作伙伴面临潜在的攻击、数据泄露，并最终导致对簿公堂。请记住，未能保护个人数据可能会导致数百万美元的罚款。

\subsubsubsection{10.1.1\hspace{0.2cm}安全设计}

何设计安全架构？最好的方法是像攻击者一样思考。有很多方法可以打破一个盒子，但会从不同角度寻找元素之间的缝隙。(对于盒子来说，这可能是在盖子和盒子底部之间。)

软件体系结构中，元素之间的连接称为接口。因为他们的主要任务是与外部互动，所以他们是整个系统中最脆弱的部分。确保接口是受保护的、直观的和健壮的，这将解决软件容易破坏的问题。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{使界面易于使用，不易误用}

要以一种既易于使用，又不易误用的方式设计接口，请考虑以下练习。假设有一个界面的客户，想实现一个使用支付网关的电子商务商店，或者想实现一个VR应用程序，连接到本书示例系统的Customer API。

作为界面设计的一般规则，应避免以下设计:

\begin{itemize}
\item 
传递给函数/方法的参数太多

\item 
参数名称不明确

\item 
使用输出参数

\item 
参数依赖于其他参数
\end{itemize}

为什么这些是有问题的呢？

\begin{itemize}
\item 
第一个，不仅很难记住，而且很难记住参数的顺序。这可能会导致使用上的错误，而错误又可能导致崩溃和安全问题。

\item 
第二个，与第一个有着相似的结果。通过减少使用界面的直觉性，用户更容易犯错误。

\item 
第三个，是第二个的变体。用户不仅记住哪些参数是输入的，哪些是输出的，而且还需要记住应该如何处理输出。谁管理资源的创建和删除？这是如何实现的？它背后的内存管理模型是什么？

现代C++中，返回包含所有必要数据的值，比以往要容易。对于pair、tuple和vector，没有理由使用输出参数。除此之外，返回值还有助于接受不修改对象状态的做法，这反过来可以减少与并发相关的问题。

\item 
最后，最后一个引入了不必要的认知负荷，就像前面的例子一样，这会导致错误和最终的失败。这样的代码也更难测试和维护，因为引入的每个更改都必须考虑到所有可能的组合。不能正确处理的组合，都是对系统的威胁。
\end{itemize}

上述规则适用于对外接口分，还应该有对内部接口应用类似的方式。方法是验证输入，确保值是正确和合理的，并防止不必要地使用接口提供的服务。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{启用资源自动管理}

内存泄漏、数据竞争和死锁也可能导致系统不稳定，这些症状都是资源管理不善的表现。尽管资源管理是一个令人头痛的话题，但有一种机制可以减少这些问题的数量。其中一种机制是自动资源管理。

这种情况下，资源可以通过操作系统访问，必须确保正确地使用它。这意味着使用动态分配的内存、打开文件、套接字、进程或线程，所有这些都需要在获取和释放时采取特定的行动，其中一些还需要在其生命周期中进行特定的操作。如果不能在正确的时间释放这些资源，就会导致泄漏。由于资源是有限的，从长远来看，当无法创建新资源时，泄漏将成为意外行为。 

资源管理在C++中是为什么如此重要？因为与许多其他高级语言不同，C++中没有垃圾收集机制，软件开发人员负责资源的生命周期。了解这个生命周期有助于创建安全和稳定的系统。

资源管理最常见的习惯用法是资源获取即初始化(RAII)。它起源于C++，也用于其他语言，如Vala和Rust。这种习惯用法使用对象的构造函数和析构函数分别分配和释放资源。通过这种方式，可以保证当保存资源的对象超出作用域时，使用的资源将释放。

标准库中这种用法的一些例子是\texttt{std::unique\_ptr}和\texttt{std::shared\_ptr}智能指针类型。其他的例子包括互斥对象——\texttt{std::lock\_guard}，\texttt{std::unique\_lock}和\texttt{std:shared\_lock}，或者文件——\texttt{std::ifstream}和\texttt{std::ofstream}。

稍后将详细讨论的指南支持库(GSL)，其也实现了一个用于自动化资源管理的指南。通过在代码中使用\texttt{gsl::finally()}，创建了一个\texttt{gsl::final\_action()}对象，并添加了一些在调用对象的析构函数时执行的代码。这意味着该代码将在函数成功返回时，以及在异常期间堆栈展开时执行。

这种方法不应该经常使用，因为在设计类时考虑到RAII通常是一个更好的主意。但是，如果您正在与第三方模块进行接口，并且希望确保包装器的安全性，finally()可以帮助您实现这一点。

假设有一个支付运营商，只允许每个帐户同时登录一次。如果不想阻止用户进行未来的支付，应该在完成交易处理后立即注销。当一切都按照我们的设计进行时，不会有任何不愉快。但在发生异常的情况下，也希望安全并释放资源。下面是使用\texttt{gsl::finally()}实现的方法:

\begin{lstlisting}[style=styleCXX]
TransactionStatus processTransaction(AccountName account, ServiceToken
token,
Amount amount)
{
	payment::login(account, token);
	auto _ = gsl::finally([] { payment::logout(); });
	payment::process(amount); // We assume this can lead to exception
	
	return TransactionStatus::TransactionSuccessful;
}
\end{lstlisting}

不管在调用\texttt{payment::process()}期间发生了什么，至少可以保证，当超出了\texttt{processTransaction()}的作用域，用户就会注销。

简而言之，使用RAII会让类设计阶段更多地考虑资源管理，同时可以完全控制代码。而当意图不清晰时，可能会较少地考虑何时使用接口。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{并发性的缺点}

虽然并发性提高了性能和资源利用率，但它也使代码更难设计和调试。因为与单线程流不同，操作的时间不能提前确定。在单线程代码中，可以向资源写入或从资源读取，但总是知道操作的顺序，因此可以预测对象的状态。

使用并发性，多个线程或进程可以同时从一个对象中读取或修改。如果修改不是原子的，就会遇到问题。看下下面的代码:

\begin{lstlisting}[style=styleCXX]
TransactionStatus chargeTheAccount(AccountNumber acountNumber, Amount
amount)
{
	Amount accountBalance = getAcountBalance(accountNumber);
	if (accountBalance > amount)
	{
		setAccountBalance(accountNumber, accountBalance - amount);
		return TransactionStatus::TransactionSuccessful;
	}
	return TransactionStatus::InsufficientFunds;
}
\end{lstlisting}

当从非并发调用\texttt{chargeTheAccount}函数时，一切都会结束。如果可能的话，程序会检查账户余额并收取费用。然而，并发执行可能导致负余额。这是因为两个线程可以一个接一个地调用\texttt{getAccountBalance()}，并返回相同的数量，比如20。执行该后，两个线程都检查当前余额是否高于可用金额。检查后，再修改帐户余额。假设两个事务的金额都是10，每个线程将设置余额为20 - 10 = 10。在两次操作后，该帐户的余额为10，但它会是0!

为了缓解类似的问题，可以使用互斥锁和临界区、CPU提供的原子操作或并发安全的数据结构等解决方案。

互斥锁、临界区和其他类似的并发设计模式防止多个线程修改(或读取)数据。尽管设计并发应用程序时很有用，但与其相关的是一种权衡。因为互斥锁保护的代码只允许单个线程执行它，所以可以使部分代码成为单线程的。其他所有的线程都必须等待，直到释放互斥锁。由于引入了等待，会降低代码的性能，但我们使用并发最初的目标是提高性能。

原子操作意味着使用单个CPU指令来获得所需的效果，这个术语可以指任何转换为单个CPU指令的高级操作。当单个指令实现的功能超过正常情况下可能实现的功能时，就特别有趣。例如，compare-and-swap(CAS)是一条指令，它将内存位置与给定值进行比较，只有当比较成功时才将该位置的内容修改为新的值。自C++11起，有\texttt{<std::atomic>}头文件可用，其包含几个原子数据类型和操作。例如，CAS可以实现为一个\texttt{compare\_and\_exchange\_*}函数集。

最后，并发安全的数据结构(也称为并发数据结构)为需要某种同步的数据结构提供了安全的抽象。例如，Boost。Lockfree(https://www.boost.org/doc/libs/1\_66\_0/doc/html/lockfree.html)库提供了用于多个生产者和多个消费者的并发队列和栈。 libcds(https://github.com/khizmax/libcds)还提供了有序list、set和map，但在本书写作时，它已经几年没有更新了。

在设计并发处理时要记住一些有用的规则:

\begin{itemize}
\item 
考虑是否需要并发。

\item 
通过值传递数据，而不是通过指针或引用。这可以防止在其他线程读取该值时修改该值。

\item 
如果数据的大小无法按值共享，请使用\texttt{shared\_ptr}。这样，可以避免资源泄漏。
\end{itemize}

\subsubsubsection{10.1.2\hspace{0.2cm}安全编码指南和GSL}

The Standard C++ Foundation released a set of guidelines to document the best practices for building C++ systems. It is a Markdown document released on GitHub under https://github.com/isocpp/CppCoreGuidelines. It is an evolving document without a release schedule (unlike the C++ standard itself). The guidelines are aimed at modern C++, which basically means code bases that implement at least C++11 features.

Many of the rules presented in the guidelines cover the topics that we present in this chapter. For example, there are rules related to interface design, resource management, and concurrency. The editors of the guidelines are Bjarne Stroustrup and Herb Sutter, both respected members of the C++ community.

We won't go into detail describing the guidelines. We encourage you to read them yourself. This book is inspired by many of the rules presented there and we follow them in our examples.

To ease the use of these rules in various code bases, Microsoft released the Guidelines Support Library (GSL) as an open source project hosted on https://github.com/microsoft/GSL. It is a header-only library that you can include in your project to use the defined types. You can either include the whole GSL or selectively use only some of the types you plan on using.

What's also interesting about the library is the fact that it uses CMake for building, Travis for continuous integration, and Catch for unit testing. It is, therefore, a good example of the topics we've covered in Chapter 7, Building and Packaging, and Chapter 8, Writing Testable Code, and Chapter 9, Continuous Integration and Continuous Deployment.

\subsubsubsection{10.1.3\hspace{0.2cm}防御性编码，验证一切}

In a previous chapter on testability, we mentioned the method of defensive programming. Even though this method is not strictly a security feature, it happens to help with creating a robust interface. Such interfaces, in turn, increase the overall security of your system.

As a good heuristic, you can treat all the external data as unsafe. What we mean by external data is every input coming to the system via some interface (either a programming interface or user interface). To denote this, you can go as far as prefixing the appropriate types as Unsafe, as follows:

\begin{lstlisting}[style=styleCXX]
RegistrationResult registerUser(UnsafeUsername username, PasswordHash
passwordHash)
{
	SafeUsername safeUsername = username.sanitize();
	try
	{
		std::unique_ptr<User> user = std::make_unique<User>(safeUsername,
		passwordHash);
		CommitResult result = user->commit();
		if (result == CommitResult::CommitSuccessful)
		{
			return RegistrationResult::RegistrationSuccessful;
		}
		else
		{
			return RegistrationResult::RegistrationUnsuccessful;
		}
	}
	catch (UserExistsException _)
	{
		return RegistrationResult::UserExists;
	}
}
\end{lstlisting}

If you have already read the guidelines, you will know that you should generally avoid using the C API directly. Some of the functions in the C API can be used in an unsafe way and require special care to use them defensively. It is much better to instead use respective concepts from C++ that ensure better type safety as well as protection (for example, against buffer overflow).

Another facet of defensive programming is the intelligent reuse of the existing code. Each time you try to implement some technique, ensure nobody else has implemented it before you. Writing a sorting algorithm yourself may be a fun challenge to do when you're learning a new programming language, but for production code, it's much better to use the sorting algorithms available in the standard library. The same goes for password hashing. No doubt you can find some clever way to calculate the password hashes and store them in a database but it is generally wiser to go with the tried and true (and don't forget peerreviewed!) bcrypt. Keep in mind that intelligent code reuse assumes you check and audit the third-party solutions with the same due diligence as  you would your own code. We will dive deeper into this topic in the next section, Are my dependencies secure?.

It's worth noting that defensive programming shouldn't turn into paranoid programming. Checking user input is a sane thing to do, while asserting whether an initialized variable is still equal to the original value just after the initialization is going too far. You want to control the integrity of your data and algorithms and the integrity of third-party solutions. You don't want to verify the correctness of your compiler by embracing language features.

In short, it's a good idea from both a security and readability point of view to use Expects() and Ensures() as presented in C++ Core Guidelines and to distinguish between unsafe and safe data through typing and conversions.

\subsubsubsection{10.1.4\hspace{0.2cm}The most common vulnerabilities}

To check whether your code is safe against the most common vulnerabilities, you should first learn about the said vulnerabilities. After all, a defense is only possible when you know what the offense looks like. The Open Web Application Security Project (OWASP) has cataloged the most common vulnerabilities and has published them at https://www.owasp.org/index.php/Category:OWASP\_Top\_Ten\_Project. At the moment of writing this book, those vulnerabilities are as follows:

\begin{itemize}
\item 
Injection: Commonly known as SQL injection. It is not limited to SQL; this vulnerability occurs when untrusted data is passed directly to an interpreter (such as a SQL database, NoSQL database, shell, or eval function). The attacker may this way gain access to parts of the system that should be protected.

\item 
Broken Authentication: If authentication is improperly implemented, attackers may use flaws to either compromise secret data or impersonate other users.

\item 
Sensitive Data Exposure: The lack of encryption and proper access rights may lead to sensitive data being exposed publicly.

\item 
XML External Entities (XXE): Some XML processors may disclose the contents of the server's filesystem or allow remote code execution.

\item 
Broken Access Control: When access control is not enforced properly, attackers may gain access to files or data that should be restricted.

\item 
Security Misconfiguration: Using insecure defaults and improper care with configuration are the most common sources of vulnerabilities.

\item 
Cross-Site Scripting (XSS): Including and executing untrusted external data, especially with JavaScript, that allows control of the user's web browser. 

\item 
Insecure Deserialization: Some flawed parsers may fall prey to denial of services attacks or remote code execution.

\item 
Using Components with Known Vulnerabilities: A lot of the code in modern applications comes as third-party components. These components should be regularly audited and updated as known security flaws in a single dependency can result in your entire application and data being compromised. Fortunately, there are tools that help automate this.

\item 
Insufficient Logging \& Monitoring: If your system is under attack and your logging and monitoring is not very thorough, the attacker may obtain deeper access and still become unnoticed.
\end{itemize}

We won't go into detail regarding each of the mentioned vulnerabilities. What we want to highlight here is that you can prevent injection, XML external entities, and insecure deserialization by following the defensive programing techniques we mentioned before. By treating all external data as unsafe, you can first sanitize it by removing all the unsafe content before you start the actual processing.

When it comes to insufficient logging and monitoring, we will go into detail in Chapter 15, Cloud-Native Design. There we will present some possible approaches to observability, including logging, monitoring, and distributed tracing.

















