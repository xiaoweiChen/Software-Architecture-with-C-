
It's not enough to distinguish between different types of tests and learn a particular testing framework (or several). When you start testing your actual code, you will soon notice that not all classes can be tested easily. Sometimes, you may feel the need to access private attributes or methods. Resist this urge if you want to maintain the principles of good architecture! Instead, consider either testing the business requirements that are available through the type's public API or refactoring the type so that there's another unit of code you can test.

\subsubsubsection{8.5.1\hspace{0.2cm}When tests and class design clash}

The problem you may be facing is not that the testing frameworks are inadequate. Usually, what you encounter is inappropriately designed classes. Even though your classes may behave correctly and may look correct unless they allow for testing, they are not designed correctly.

However, this is good news. It means that you can repair the problem before it's inconvenient to do so. The class design will probably haunt you later on when you start building a class hierarchy based on it. Fixing the design during test implementation will simply reduce the possible technological debt.

\subsubsubsection{8.5.3\hspace{0.2cm}Defensive programming}

Unlike its name may suggest, defensive programming is not a security feature. Its name comes from defending your classes and functions from being used contrary to their original intention. It's not directly related to testing, but it's a great design pattern to use since it improves your code's quality, making your project future-proof.

Defensive programming starts with static typing. If you create a function that handles a custom-defined type as a parameter, you must make sure nobody will call it with some accidental value. A user will have to consciously check what the function expects and prepare the input accordingly.

In C++, we can also leverage type-safety features when we're writing template code. When we're creating a container for our customers' reviews, we could accept a list of any type and copy from it. To get nicer errors and well-crafted checks, we could write the following:

\begin{lstlisting}[style=styleCXX]
class CustomerReviewStore : public i_customer_review_store {
public:
	CustomerReviewStore() = default;
	explicit CustomerReviewStore(const std::ranges::range auto
	&initial_reviews) {
		static_assert(is_range_of_reviews_v<decltype(initial_reviews)>,
			"Must pass in a collection of reviews");
		std::ranges::copy(begin(initial_reviews), end(initial_reviews),
			begin(reviews_));
	}
// ...
private:
	std::vector<review> reviews_;
};
\end{lstlisting}

The explicit keyword protects us from unwanted implicit casts. By specifying that our input parameter satisfies the range concept, we ensure that we're only going to compile with a valid container. Thanks to using concepts, we can get clearer error messages from our defense against invalid use. Using static\_assert in our code is also a great defensive measure as it allows us to provide a nice error message if needed. Our is\_range\_of\_reviews check could be implemented as follows:

\begin{lstlisting}[style=styleCXX]
template <typename T>
	constexpr bool is_range_of_reviews_v =
		std::is_same_v<std::ranges::range_value_t<T>, review>;
\end{lstlisting}

This way, we ensure that the range we got actually contains reviews of the type we desire.

Static typing will not prevent invalid runtime values from being passed to the function. That's why the next form of defensive programming is checking preconditions. This way, your code will fail as soon as the first sign of a problem arises, which is always better than returning an invalid value that propagates to other parts of the system. Until we have contracts in C++, we can use the GSL library we mentioned in earlier chapters to check the pre- and post-conditions of our code:

\begin{lstlisting}[style=styleCXX]
void post_review(review review) final {
	Expects(review.merchant);
	Expects(review.customer);
	Ensures(!reviews_.empty());
	
	reviews_.push_back(std::move(review));
}
\end{lstlisting}

Here, by using the Expects macro, we're checking that our incoming review actually has the IDs of the merchant and reviewer set. Aside from the cases where it doesn't, we are also defending ourselves against cases where adding a review to our storage failed when we use the Ensures post-condition macro.

When it comes to runtime checks, one of the first things that comes to mind is checking whether one or more attributes is not a nullptr. The best way to guard yourself against this problem is to distinguish nullable resources (those that can take nullptr as value) from non-nullable ones. There's a great tool you can use for this, and is available in the standard library from C++17: std::optional. If you can, use it in all the APIs that you design.

\subsubsubsection{8.5.3\hspace{0.2cm}The boring refrain â€“ write your tests first}

This has been said many times, yet many people tend to "forget" this rule. When you actually write your tests, the first thing you must do is reduce the risk of creating classes that are hard to test. You start with API usage and need to bend the implementation to best serve the API. This way, you usually end up with APIs that are both more pleasant to use and easier to test. When you're implementing test-driven development (TDD) or writing tests before code, you'll also end up implementing dependency injection, which means your classes can be more loosely coupled.

Doing this the other way around (writing your classes first and only then adding unit tests to them) may mean that you up with code that is easier to write but harder to test. And when testing gets harder, you may feel the temptation to skip it.













