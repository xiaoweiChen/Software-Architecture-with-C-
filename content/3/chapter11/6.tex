In this chapter, we've learned what types of tools can help us achieve better performance with our code. We learned how to perform experiments, write performance tests, and look for performance bottlenecks. You're now able to write microbenchmarks using Google Benchmark. Moreover, we discussed how to profile your code and how (and why) to implement distributed tracing of your system. We also discussed parallelizing your computations using both standard library utilities and external solutions. Last but not least, we introduced you to coroutines. You now know what C++20 brings to the coroutine table, as well as what you can find in the cppcoro library. You've also learned how to write your own coroutines.

The most important lesson from this chapter is: when it comes to performance, measure first and optimize later. This will help you maximize the impact of your work.

That's it for performance â€“ the last of quality attributes we wanted to discuss in our book. In the next chapter, we'll start moving into the world of services and the cloud. We'll start by discussing service-oriented architecture.
























