By now, you should have learned how implementing CI at the beginning of the project can help you save time in the long run. It can also reduce work in progress, especially when paired with CD. In this chapter, we've presented useful tools that can help you implement both of the processes.

We've shown how GitLab CI allows us to write pipelines in YAML files. We've discussed the importance of code review and explained the differences between the various forms of code review. We've introduced Ansible, which assists in configuration management and the creation of deployment code. Finally, we tried Packer and Terraform to move our focus from creating applications to creating systems.

The knowledge in this chapter is not unique to the C++ language. You can use it in projects written in any language using any technology. The important thing that you should keep in mind is this: all applications require testing. A compiler or a static analyzer is not enough to validate your software. As an architect, you would also have to take into account not only your project (the application itself), but also the product (the system your application will work in). Delivering working code is no longer sufficient. Understanding the infrastructure and the process of deployment is crucial as they are the new building blocks of modern systems.

The next chapter is focused on the security of the software. We will cover the source code itself, the operating system level, and the possible interactions with external services as well as with end users.