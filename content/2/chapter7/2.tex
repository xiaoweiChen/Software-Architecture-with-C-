
Compilers are one of the most important tools in every programmer's workshop. That's why getting to know them well can help you out in many different ways, on countless occasions. In this section, we'll describe a few tips to use them effectively. This will only touch the tip of the iceberg as whole books can be written about these tools and their vast variety of available flags, optimizations, functionalities, and other specifics. GCC even has a wiki page with a list of books about compilers! You can find it in the Further reading section at the end of this chapter.

\subsubsubsection{7.2.1\hspace{0.2cm}Using multiple compilers}

One of the things you should consider in your build process is using multiple compilers instead of just one, the reason being the several benefits that come with it. One of them is that they can detect different issues with your code. For instance, MSVC has signedness checks enabled by default. Using several compilers can help with potential portability issues you may encounter in the future, especially when a decision is made to also compile your code on a different OS, such as moving from Linux to Windows or the other way. To make such efforts at no cost, you should strive to write portable, ISO C++-compliant code. One of the benefits of Clang is that it strives for compliance with the C++ standards more than GCC. If you're using MSVC, try adding the /permissive- option (available since Visual Studio 17; enabled by default for projects created using version 15.5+). For GCC, try not to use the GNU variants when choosing the C++ standard for your code (for example, prefer -std=c++17 to -std=gnu++17). If performance is your goal, being able to build your software with a wide range of compilers will also allow you to pick the one that will offer the fastest binaries for your specific use cases. 

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black, title=TIP]
\hspace*{0.7cm}Regardless of which compiler you choose for your release builds, consider using Clang for development. It runs on macOS, Linux, and Windows, supports the same set of flags as GCC, and aims to provide the fastest build times and concise compilation errors.
\end{tcolorbox}

If you're using CMake, you have two common ways to add another compiler. One is to pass the appropriate compilers when invoking CMake, like so:

\begin{tcblisting}{commandshell={}}
mkdir build-release-gcc
cd build-release-gcc
cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=/usr/bin/gcc -
DCMAKE_CXX_COMPILER=/usr/bin/g++
\end{tcblisting}

It's also possible to just set CC and CXX before invoking CMake, but those variables are not honored on all platforms (such as macOS).

Another approach is to use toolchain files. It's probably an overkill if you just need to use a different compiler, but it's the go-to solution when you want to cross-compile. To use a toolchain file, you should pass it as a CMake argument: -DCMAKE\_TOOLCHAIN\_FILE=toolchain.cmake. 

\subsubsubsection{7.2.2\hspace{0.2cm}Reducing build times}

Every year, programmers spend countless hours waiting for their builds to complete. Reducing build times is an easy way to improve the productivity of whole teams, so let's discuss a few approaches to doing it.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Using a fast compiler}

One of the simplest ways to have faster builds is sometimes to upgrade your compiler. For instance, by upgrading Clang to 7.0.0, you could shave up to 30\% off of build times using Precompiled Header (PCH) files. Since Clang 9, it has gained the -ftime-trace option, which can provide you with information on the compilation times of all the files it processes. Other compilers have similar switches, too: check out GCC's -ftime-report or MSVC's /Bt and /d2cgsummary. Often you can get faster compiles by switching the compiler, which is especially useful on your development machine; for example, Clang usually compiles code faster than GCC.

Once you have a fast compiler, let's take a look at what it needs to compile.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Rethinking templates}

Different parts of the compilation process take a different amount of time to complete. This is especially important for compile-time constructs. One of Odin Holmes' interns, Chiel Douwes, created the so-called Rule of Chiel based on benchmarking the compile-time costs of various template operations. This, and other type-based template metaprogramming tricks, can be seen in the Type Based Template Metaprogramming is Not Dead lecture by Odin Holmes. From fastest to slowest, they are as follows:

\begin{itemize}
\item 
Looking up a memoized type (for example, a template instantiation)

\item 
Adding a parameter to an alias call

\item 
Adding a parameter to a type

\item 
Calling an alias

\item 
Instantiating a type

\item 
Instantiating a function template

\item 
Using SFINAE (Substitution Failure Is Not an Error)
\end{itemize}

To demonstrate this rule, consider the following code:

\begin{lstlisting}[style=styleCXX]
template<bool>
struct conditional {
	template<typename T, typename F>
	using type = F;
};

template<>
struct conditional<true> {
	template<typename T, typename F>
	using type = T;
};

template<bool B, typename T, typename F>
using conditional_t = conditional<B>::template type<T, F>;
\end{lstlisting}

It defines a conditional template alias, which stores a type that resolves as T if condition B is true, and to F otherwise. The traditional way to write such a utility would be as follows:

\begin{lstlisting}[style=styleCXX]
template<bool B, class T, class F>
struct conditional {
	using type = T;
};

template<class T, class F>
struct conditional<false, T, F> {
	using type = F;
};

template<bool B, class T, class F>
using conditional_t = conditional<B,T,F>::type;
\end{lstlisting}

However, this second way is slower to compile than the first because it relies on creating template instances instead of type aliases.

Let's now take a look at what tools and their features you can use to keep compile times low.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Leveraging tools}

A common technique that can make your builds faster is to use a single compilation unit build, or unity build. It won't speed up every project, but it may be worth a shot if there's plenty of code in your header files. Unity builds work by just including all your .cpp files in one translation unit. Another similar idea is to use pre-compiled headers. Plugins such as Cotire for CMake will handle both of these techniques for you. CMake 3.16 also adds native support for unity builds, which you can enable either for one target, set\_target\_properties(<target> PROPERTIES UNITY\_BUILD ON), or globally by setting CMAKE\_UNITY\_BUILD to true. If you just want PCHs, you might want to take a look into CMake 3.16's target\_precompile\_headers.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black, title=TIP]
\hspace*{0.7cm}If you feel like you are including too much in your C++ files, consider using a tool named include-what-you-use to tidy them up. Preferring forward declaring types and functions to including header files can also go a long way in reducing the compilation times.
\end{tcolorbox}

If your project takes forever to link, there are some ways to deal with this as well. Using a different linker, such as LLVM's LLD or GNU's Gold, can help a lot, especially since they allow multi-threaded linking. If you can't afford to use a different linker, you can always experiment with flags such as -fvisibility-hidden or -fvisibility-inlineshidden and mark only the functions you want to have visible in your shared library with an appropriate annotation in the source code. This way, the linker will have less work to perform. If you're using link-time optimization, try to only do that for the builds that are performance-critical: those that you plan to profile and those meant for production. Otherwise, you'll probably just waste your developers' time.

If you're using CMake and aren't tied to a specific generator (for example, CLion requires using the Code::Blocks generator), you can replace the default Make generator with a faster one. Ninja is a great one to start with as it was created specifically to reduce build times. To use it, just pass -G Ninja when invoking CMake.

There are still two more great tools that will surely give you a boost. One of them is Ccache.It's a tool that runs its cache of C an d C++ compilation outputs. If you're trying to build the same thing twice, it will get the results from the cache instead of running the compilation. It keeps the statistics, such as cache hits and misses, can remember the warnings that it should emit when compiling a specific file, and has many configuration options that you can store in the ~/.ccache/ccache.conf file. To obtain its statistics, just run ccache -\,-show-stats.

The second tool is IceCC (or Icecream). It's a fork of distcc, essentially a tool to distribute your builds across hosts. With IceCC, it's easier to use a custom toolchain. It runs the iceccd daemon on each host and an icecc-scheduler service that manages the whole cluster. The scheduler, unlike in distcc, makes sure to only use the idle cycles on each machine, so you won't end up overloading other people's workstations.

To use both IceCC and Ccache for your CMake builds, just add -DCMAKE\_C\_COMPILER\_LAUNCHER="ccache;icecc" -DCMAKE\_CXX\_COMPILER\_LAUNCHER="ccache;icecc" to your CMake invocation. If you're compiling on Windows, instead of the last two tools, you could use clcache and Incredibuild or look for other alternatives.

Now that you know how to build fast, let's move on to another important topic.

\subsubsubsection{7.2.3\hspace{0.2cm}Finding potential code issues}

Even the quickest builds aren't worth much if your code has bugs. There are dozens of flags to warn you of potential issues in your code. This section will try to answer which ones you should consider enabling.

First, let's start with a slightly different matter: how not to get warned about issues with code from other libraries. Getting warned about issues that you can't really fix isn't useful. Fortunately, there are compiler switches to disable such warnings. In GCC, for instance, you have two types of include files: regular (passed using -I) and system ones (passed using -isystem). If you specify a directory using the latter, you won't get warnings from the headers it contains. MSVC has an equivalent for -isystem: /external:I.Additionally, it has other flags to handle external includes, such as /external:anglebrackets, which tells the compiler to treat all files included using angle brackets as external ones, thus disabling warnings for them. You can specify a warning level for external files. You can also keep warnings coming from template instantiations caused by your code using /external:templates-. If you're looking for a portable way to mark include paths as system/external ones, and you're using CMake, you can add the SYSTEM keyword to a target\_include\_directories directive.

Speaking of portability, if you want to be conformant to a C++ standard (and you should), consider adding -pedantic to your compile options for GCC or Clang, or the /permissive- option for MSVC. This way, you'll get informed about every non-standard extension that you might be using. If you're using CMake, add the following line for each of your targets, set\_target\_properties(<target> PROPERTIES CXX\_EXTENSIONS OFF), to disable compiler-specific extensions.

If you're using MSVC, strive to compile your code with /W4, since it enables most of the important warnings. For GCC and Clang, try to use -Wall -Wextra -Wconversion -Wsign-conversion. The first one, despite its name, enables only some common warnings. The second, however, adds another bunch of warnings. The third one is based on the tips from a great book by Scott Meyers, titled Effective C++ (it's a set of good warnings, but check that it's not too noisy for your needs). The last two are about type conversions and signedness conversions. All those flags together create a sane safety net, but you can, of course, look for more flags to enable. Clang has a -Weverything flag. Try to periodically run a build with it to discover new, potential warnings that could be worth enabling in your codebase. You might be surprised at how many messages you get with this flag, although enabling some of the warning flags might not be worth the hassle. An MSVC alternative is named /Wall. Take a look at the following tables to see some other interesting options that are not enabled by the preceding 9:

GCC/Clang:
\begin{table}[H]
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Flag}         & \textbf{Meaning}                                                                                                                                    \\ \hline
		-Wduplicated-cond     & \begin{tabular}[c]{@{}l@{}}Warn when the same condition is used in if and else-if\\ blocks.\end{tabular}                                            \\ \hline
		-Wduplicated-branches & Warn if both branches contain the same source code.                                                                                                 \\ \hline
		-Wlogical-op          & \begin{tabular}[c]{@{}l@{}}Warn when operands in logical operations are the same and\\ when a bitwise operator should be used instead.\end{tabular} \\ \hline
		-Wnon-virtual-dtor    & \begin{tabular}[c]{@{}l@{}}Warn when a class has virtual functions but not a virtual\\ destructor.\end{tabular}                                     \\ \hline
		-Wnull-dereference    & \begin{tabular}[c]{@{}l@{}}Warn about null dereferences. This check may be inactive in\\ unoptimized builds.\end{tabular}                           \\ \hline
		-Wuseless-cast        & Warn when casting to the same type.                                                                                                                 \\ \hline
		-Wshadow              & \begin{tabular}[c]{@{}l@{}}A whole family of warnings about declarations that shadow\\ other, previous declarations.\end{tabular}                   \\ \hline
	\end{tabular}
\end{table}

MSVC:

\begin{table}[H]
	\begin{tabular}{|l|l|}
		\hline
		\textbf{Flag} & \textbf{Meaning}                                      \\ \hline
		/w44640       & Warn on non-thread-safe static member initialization. \\ \hline
	\end{tabular}
\end{table}

One last thing worth mentioning is the question: to -Werror (or /WX on MSVC) or not to - Werror? This really depends on your personal preferences as issuing errors instead of warnings has its pros and cons. On the plus side, you won't let any of your enabled warnings slip by. Your CI build will fail and your code won't compile. When running multi-threaded builds, you won't lose any warnings in the quickly passing compilation messages. However, there are some minuses too. You won't be able to upgrade your compiler if it enables any new warnings or just detects more issues. The same goes for dependencies, which can deprecate some functions they provide. You won't be able to deprecate anything in your code if it's used by other parts of your project. Fortunately, you can always use a mixed solution: strive to compile with -Werror, but disable it when you need to do the things it inhibits. This requires discipline, as if any new warnings are to slip in, you may have a hard time eliminating them.

\subsubsubsection{7.2.4\hspace{0.2cm}Using compiler-centric tools}

Nowadays, compilers allow you to do much more with them than a few years back. This is owing to the introduction of LLVM and Clang. By providing APIs and a modular architecture allowing easy reuse, caused tools such as sanitizers, automatic refactoring, or code completion engines to flourish. You should consider taking advantage of what this compiler infrastructure offers you. Use clang-format to ensure all the code in your code base conforms to a given standard. Consider adding pre-commit hooks using the precommit tool to reformat new code before commit. You can also add Python and CMake formatters to the mix. Statically analyze the code using clang-tidy – a tool that actually understands your code instead of just reasoning about it. There's a ton of different checks this tool can perform for you, so be sure to customize the list and options to your specific needs. You can also run nightly or weekly tests of your software with sanitizers enabled. This way, you can detect threading issues, undefined behavior, memory access, management issues, and more. Running tests using debug builds can also be of value if your release builds have assertions disabled.

If you think that more could be done, you can consider writing your own code refactorizations using Clang's infrastructure. There's already a clang-rename tool if you want to see how to create an LLVM-based tool of your own. Additional checks and fix-its for clang-tidy are also not that hard to create, and they can save you hours of manual labor.

You can integrate many tools into your building process. Let's now discuss the heart of the process: the build system.












