
CMake有内置的实用程序，在分发构建的结果时，这些实用程序可以大有作为。本节将描述安装和导出实用程序，以及它们之间的区别。后面的小节将展示如何使用CPack打包代码，以及如何使用Conan进行打包。

安装和导出对于微服务本身并不是那么重要，但如果会交付库供他人重用，这就就非常有用了。

\subsubsubsection{7.5.1\hspace{0.2cm}安装}

如果编写或使用过Makefile，那么应该用过\texttt{make install}，并看到过项目的可交付成果是如何安装在OS目录或选择的另一个目录中的。如果正在使用make与CMake，使用本节的步骤将可以以相同的方式安装可交付成果。当然，如果没有，仍然可以使用安装目标。除此之外，在这两种情况下，将有一种简单的方法来使用CPack根据安装命令来创建安装包。

如果在Linux系统上，通过调用下面的命令根据操作系统的惯例预先设置一些安装目录，可能是个不错的方式:

\begin{lstlisting}[style=styleCMake]
include(GNUInstallDirs)
\end{lstlisting}

这将使安装程序使用由bin、lib和其他类似目录组成的目录结构。这样的目录也可以手动设置一些CMake变量。

创建安装目标还包括几个步骤。首先，也是最重要的是定义想要安装的目标，在例子中如下所示:

\begin{lstlisting}[style=styleCMake]
install(
	TARGETS libcustomer customer
	EXPORT CustomerTargets
	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
	ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR})
\end{lstlisting}

这告诉CMake将本章前面定义的库和可执行文件公开为\texttt{CustomerTargets}，使用前面设置的目录。

如果计划将库的不同配置安装到不同的文件夹中，可以这样:

\begin{lstlisting}[style=styleCMake]
install(TARGETS libcustomer customer
	CONFIGURATIONS Debug
	# destinations for other components go here...
	RUNTIME DESTINATION Debug/bin)
	
install(TARGETS libcustomer customer
	CONFIGURATIONS Release
	# destinations for other components go here...
	RUNTIME DESTINATION Release/bin)
\end{lstlisting}

可以注意到，这里为可执行文件和库指定了目录，但没有为包含文件指定目录。这需要在另一个命令中提供它们，像这样:

\begin{lstlisting}[style=styleCMake]
install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/
	DESTINATION include)
\end{lstlisting}

这意味着顶层\texttt{include}目录的内容将安装在安装根目录下的\texttt{include}目录中。第一个路径后的斜杠修复了一些路径问题，所以需要留意一下它。

现在有一系列的目标，需要生成一个文件，让另一个CMake项目可以了解相应的意图。这可以通过以下方式实现:

\begin{lstlisting}[style=styleCMake]
install(
	EXPORT CustomerTargets
	FILE CustomerTargets.cmake
	NAMESPACE domifair::
	DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Customer)
\end{lstlisting}

这个命令接受目标集，并创建一个CustomerTargets.cmake文件，将包含关于目标和要求的所有信息。每个目标都有一个名称空间前缀，例如：\texttt{customer}将变成\texttt{domifair::customer}。生成的文件将安装在安装树中的库文件夹子目录中。

为了让依赖项目使用CMake的\texttt{find\_package}找到相应的目标，需要提供一个CustomerConfig.cmake文件。如果目标没有依赖项，可以直接将前面的目标导出到该文件，而不是目标文件。否则，应该编写包含上述目标文件的自己的配置文件。

在例子中，想要重用一些CMake变量，所以需要创建一个模板，并使用\texttt{configure\_file}对其进行填充:

\begin{lstlisting}[style=styleCMake]
configure_file(${PROJECT_SOURCE_DIR}/cmake/CustomerConfig.cmake.in
	CustomerConfig.cmake @ONLY)
\end{lstlisting}

Our CustomerConfig.cmake.in file will begin by dealing with our dependencies:

\begin{lstlisting}[style=styleCMake]
include(CMakeFindDependencyMacro)
find_dependency(cpprestsdk 2.10.18 REQUIRED)
\end{lstlisting}

The find\_dependency macro is a wrapper for find\_package that is meant to be used in config files. Although we relied on Conan to provide us with the C++ REST SDK 2.10.18 as defined in conanfile.txt, here we need to specify the dependency once more. Our package can be used on another machine, so we require that our dependency is installed there too. If you want to use Conan on the target machine, you can install the C++ REST SDK as follows:

\begin{tcblisting}{commandshell={}}
conan install cpprestsdk/2.10.18
\end{tcblisting}

After dealing with the dependencies, our config file template will include the targets file that we created earlier:

\begin{lstlisting}[style=styleCMake]
if(NOT TARGET domifair::@PROJECT_NAME@)
	include("${CMAKE_CURRENT_LIST_DIR}/@PROJECT_NAME@Targets.cmake")
endif()
\end{lstlisting}

When configure\_file executes, it will replace all those @VARIABLES@ with the contents of their matching \$\{VARIABLES\} defined in our project. This way, based on our CustomerConfig.cmake.in file template, CMake will create a CustomerConfig.cmake file.

When finding a dependency using find\_package, you'll often want to specify a version of the package to find. To support that in our package, we must create a CustomerConfigVersion.cmake file. CMake offers us a helper function that will create this file for us. Let's use it as follows:

\begin{lstlisting}[style=styleCMake]
include(CMakePackageConfigHelpers)
write_basic_package_version_file(
CustomerConfigVersion.cmake
VERSION ${PACKAGE_VERSION}
COMPATIBILITY AnyNewerVersion)
\end{lstlisting}

The PACKAGE\_VERSION variable will get populated according to the VERSION argument we passed when calling project at the top of our top-level CMakeLists.txt file.

AnyNewerVersion COMPATIBILITY means our package will be accepted by any package search if it is newer or the same as the requested version. Other options include SameMajorVersion, SameMinorVersion, and ExactVersion.

Once we have created our config and config version files, let's tell CMake that they should be installed along with the binaries and our target file:

\begin{lstlisting}[style=styleCMake]
install(FILES ${CMAKE_CURRENT_BINARY_DIR}/CustomerConfig.cmake
		${CMAKE_CURRENT_BINARY_DIR}/CustomerConfigVersion.cmake
	DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/Customer)
\end{lstlisting}

One last thing we should install is the license for our project. We'll leverage CMake's command for installing files to put them in our documentation directory:

\begin{lstlisting}[style=styleCMake]
install(
	FILES ${PROJECT_SOURCE_DIR}/LICENSE
	DESTINATION ${CMAKE_INSTALL_DOCDIR})
\end{lstlisting}

That's all you need to know to successfully create an install target in the root of your OS. You may ask how to install the package into another directory, such as just for the current user. To do so, you would need to set the CMAKE\_INSTALL\_PREFIX variable, for example, when generating the build system.

Note that if we don't install into the root of our Unix tree, we'll have to provide the dependent project with a path to the installation directory, such as by setting CMAKE\_PREFIX\_PATH.

Let's now look at yet another way you could reuse what you just built.

\subsubsubsection{7.5.2\hspace{0.2cm}导出}

Exporting is a technique to add information about a package that you built locally to CMake's package registry. This is useful when you want your targets to be visible right from their build directories, even without installation. A common use for exporting is when you have several projects checked out on your development machine and you build them locally.

It's quite easy to add support for this mechanism from your CMakeLists.txt files. In our case, it can be done in this way:

\begin{lstlisting}[style=styleCMake]
export(
	TARGETS libcustomer customer
	NAMESPACE domifair::
	FILE CustomerTargets.cmake)

set(CMAKE_EXPORT_PACKAGE_REGISTRY ON)
export(PACKAGE domifair)
\end{lstlisting}

This way, CMake will create a targets file similar to the one from the Installing section, defining our library and executable targets in the namespace we provided. From CMake 3.15, the package registry is disabled by default, so we need to enable it by setting the appropriate preceding variable. Then, we can put the information about our targets right into the registry by exporting our package.

Note that we now have a targets file without a matching config file. This means that if our targets depend on any external libraries, they must be found before our package is found. In our case, the calls must be ordered in the following way:

\begin{lstlisting}[style=styleCMake]
find_package(cpprestsdk 2.10.18)
find_package(domifair)
\end{lstlisting}

First, we find the C++ REST SDK, and only afterward do we look for our package that depends on it. That's all you need to know to start exporting your targets. Much easier than installing them, isn't it?

Let's now move on to a third way of exposing your targets to the external world.

\subsubsubsection{7.5.3\hspace{0.2cm}CPack}

In this section, we'll describe how to use CPack, the packaging tool that comes with CMake. CPack allows you to easily create packages in various formats, ranging from ZIP and TGZ archives through to DEB and RPM packages, and even installation wizards such as NSIS or a few OS X-specific ones. Once you have your installation logic in place, it's not hard to integrate the tool. Let's show how to use CPack to package our project.

First, we need to specify variables that CPack will use when creating the packages:

\begin{lstlisting}[style=styleCMake]
set(CPACK_PACKAGE_VENDOR "Authors")
set(CPACK_PACKAGE_CONTACT "author@example.com")
set(CPACK_PACKAGE_DESCRIPTION_SUMMARY
	"Library and app for the Customer microservice")
\end{lstlisting}

We need to give some information by hand, but some variables can be filled based on our project version specified when we defined our project. There are many more CPack variables and you can read about all of them in the CPack link in the Further reading section at the end of the chapter. Some of them are common for all package generators, while some are specific to a few of them. For instance, if you plan to use the installers, you could set the following two:

\begin{lstlisting}[style=styleCMake]
set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE")
set(CPACK_RESOURCE_FILE_README "${PROJECT_SOURCE_DIR}/README.md")
\end{lstlisting}

Once you've set all the interesting variables, it's time to choose the generators for CPack to use. Let's start with putting some basic ones in CPACK\_GENERATOR, a variable CPack relies on:

\begin{lstlisting}[style=styleCMake]
list(APPEND CPACK_GENERATOR TGZ ZIP)
\end{lstlisting}

This will cause CPack to generate those two types of archives based on the installation steps we defined earlier in the chapter.

You can select different package generators based on many things, for example, the tools available on the machine you're running on. An example would be to create Windows installers when building on Windows and a DEB or RPM package if building on Linux with the appropriate tools installed. For instance, if you're running Linux, you could check whether dpkg is installed and if so, create DEB packages:

\begin{lstlisting}[style=styleCMake]
if(UNIX)
	find_program(DPKG_PROGRAM dpkg)
	if(DPKG_PROGRAM)
		list(APPEND CPACK_GENERATOR DEB)
		set(CPACK_DEBIAN_PACKAGE_DEPENDS "${CPACK_DEBIAN_PACKAGE_DEPENDS}
		libcpprest2.10 (>= 2.10.2-6)")
		set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
	else()
		message(STATUS "dpkg not found - won't be able to create DEB
		packages")
	endif()
\end{lstlisting}

We used the CPACK\_DEBIAN\_PACKAGE\_DEPENDS variable to make the DEB package require the C++ REST SDK to be installed first.

For RPM packages, you could manually check for rpmbuild:

\begin{lstlisting}[style=styleCMake]
	find_program(RPMBUILD_PROGRAM rpmbuild)
	if(RPMBUILD_PROGRAM)
		list(APPEND CPACK_GENERATOR RPM)
		set(CPACK_RPM_PACKAGE_REQUIRES "${CPACK_RPM_PACKAGE_REQUIRES} cpprest
		>= 2.10.2-6")
	else()
		message(STATUS "rpmbuild not found - won't be able to create RPM packages")
	endif()
endif()
\end{lstlisting}

Nifty, right?

These generators offer a plethora of other useful variables, so feel free to look at CMake's documentation if you need anything more than those basic needs described here.

One last thing when it comes variables – you can also use them to avoid accidentally packaging undesired files. This can be done by using the following:

\begin{lstlisting}[style=styleCMake]
set(CPACK_SOURCE_IGNORE_FILES /.git /dist /.*build.* /\\\\.DS_Store)
\end{lstlisting}

Once we have all that in place, we can include CPack itself from our CMake lists:

\begin{lstlisting}[style=styleCMake]
include(CPack)
\end{lstlisting}

Remember to always do this as the last step, as CMake won't propagate any variables you used later to CPack. 

To run it, directly invoke either just cpack or the longer form that will also check whether anything needs rebuilding first: cmake -\,-build . -\,-target package. You can easily override the generators if you just need to rebuild one type of package using the -G flag, for example, -G DEB to build just the DEB package, -G WIX -C Release to pack a release MSI executable, or -G DragNDrop to obtain a DMG installer.

Let's now discuss a more barbaric way of building packages.
