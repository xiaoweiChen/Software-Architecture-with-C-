In this chapter, we've learned quite a lot of stuff. You now know when to apply which service model and how to avoid the common pitfalls of designing distributed systems. You've learned about the CAP theorem and what practical outcomes it has for distributed architectures. You can now run transactions in such systems successfully, reduce theirdowntime, prevent issues, and gracefully recover from errors. Dealing with unusually high load is no longer black magic. Integrating parts of your system, even legacy ones, with your newly designed parts is also something you're able to perform. You now also have some tricks up your sleeve to increase the performance and scalability of your system. Deploying and load balancing your system are also demystified, so you can now perform them efficiently. Last but not least, discovering services and designing and managing their APIs are all things that you have now learned to perform. Nice!

In the next chapter, we'll learn how you can use specific C++ features to travel on the road to excellent architecture in a more pleasant and efficient way.