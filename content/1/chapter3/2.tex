
While creating a software system, you should constantly ask yourself whether what you're making is what your customers need. Many times, they won't even know what requirement fulfills their needs best. It's the role of a successful architect to discover the requirements of the product and to make sure they are being met. There are three distinct types of requirements that you need to consider: functional requirements, quality attributes, and constraints. Let's have a look at each of these.

\subsubsubsection{3.2.1\hspace{0.2cm}Functional requirements}

The first group is the functional requirements. These are the ones that define what your system should do, or what functionality it should offer.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black, title=TIP]
\hspace*{0.7cm}Remember that functionality does not always influence architecture, so you'll have to keep an eye on which of those requirements will actually dictate what your solution will look like.
\end{tcolorbox}

Often, if a functional requirement has some qualities that must be met, it can become architecturally significant. Consider an app for merchants and visitors of the Dominican Fair, an annual event with music, various arts, and shops, happening in the city of Gdańsk. A few examples of functional requirements for it could be the following:

\begin{itemize}
\item \textit{UAs a shopkeeper, I want to filter orders that contain a specific product.}
\item \textit{Clicking the Subscribe button adds the customer to a list of notified watchers of a selected merchant.}
\end{itemize}

The first of those requirements tells us we'll have to have a component for tracking orders and products with search capabilities. Depending on how exactly the UI should appear and what scale our app should be, we could just add a simple page to our app, or it could require features such as Lucene or Elasticsearch. This means that we could be looking at an \textbf{Architecturally Significant Requirement (ASR)}, one that can influence our architecture.

The second example is even more straightforward; now we know we need to have a service for subscribing and sending notifications. This is definitely an architecturally significant functional requirement. Let's now look at some \textbf{Non-Functional Requirements (NFRs)} that can also be ASRs.

By the way, the first requirement is actually given as a user story. User stories are requirements given in the following format: "\textit{As a <role>, I can/want to <capability>, so that <benefit>.}" This is a common way to phrase requirements and can help stakeholders and developers find common ground and communicate better.

\subsubsubsection{3.2.2\hspace{0.2cm}Nonfunctional requirements}

Instead of focusing on what functionality your system should have, nonfunctional requirements focus on how well and under which conditions the system should perform said functionality. This group consists of two main subgroups: \textbf{Quality Attributes (QAs)} and \textbf{constraints}.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Quality attributes}

\textbf{Quality attributes (QAs)} are the traits of your solution, such as performance, maintainability, and user-friendliness. There are dozens, if not hundreds, of different qualities your software can have. Try to focus just on the important ones instead of listing all that come to your mind when choosing which ones your software should have. Examples of quality attribute requirements include the following:

\begin{itemize}
\item 
The system will respond in under 500 ms for 99.9\% of all requests under usual load (don't forget to specify what the usual load is or will be).

\item 
The website will not store customer credit card data used in the payment process (an example of confidentiality).

\item
When updating the system, if updating any component fails, the system will be rolled back to a state prior to the update (survivability).
 
\item 
As a user of Windows, macOS, and Android, I want to be able to use the system from all of them (portability; try to understand whether it's needed to support platforms such as desktop, mobile, and/or web).
\end{itemize}

While catching functional requirements in a backlog is pretty straightforward, we cannot say the same regarding quality attribute requirements. Fortunately, there are a few ways you could approach this:

\begin{itemize}
\item 
Some of them can be expressed in the \textbf{Definition of done} or \textbf{Acceptance criteria} for your tasks, stories, and releases.

\item 
Others can be expressed directly as user stories, as shown in the last example previously.

\item 
You can also check them as part of design and code reviews and create automated tests for some of them.
\end{itemize}

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{Constraints}

Constraints are the non-negotiable decisions that you must follow while delivering the project. Those can be design decisions, technological ones, or even political (regarding people or organizational matters). Two other common constraints are \textbf{time} and \textbf{budget}. Examples of constraints could be as follows:

\begin{itemize}
\item 
\textit{The team will never grow beyond four developers, one QA engineer, and one sysadmin.}

\item 
\textit{Since our company leverages Oracle DB in all its current products, the new product must use it too so we can make the most of our expertise.
}
\end{itemize}

nonfunctional requirements are always going to influence your architecture. It's essential not to over-specify them, as having false positives will be a constant burden during product development. It's equally important to not under-specify them as this can later come out in missed sales opportunities or failing to comply with regulatory bodies' requirements.

In the next section, you will learn how to strike a balance between those two extremes and to focus on just those requirements that really matter in your specific case.




