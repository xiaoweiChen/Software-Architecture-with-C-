
Architecture is way too complex a topic to be described by a single big diagram. Imagine you're the architect of a building. To design the whole thing, you'd need separate diagrams for different aspects: one for plumbing, another one for electricity and other cables, and so on. Each of those diagrams would show a different view of the project. The same goes for software architecture: you need to present the software from different perspectives, aimed at different stakeholders.

Moreover, if you were building a smart house, chances are you would draw some plan of the devices you want to place around. Although not all projects will require such views, since it plays a role in your project, it may be worth adding it. The same approach is also valid for architecture: if you find a different view valuable to the document, you should do it. So, how do you know which views could be valuable? You can try to perform the following steps:

\begin{enumerate}
\item
Start with the views from either the 4+1 model or the C4 model.

\item 
Ask your stakeholders what is essential for them to have documented and think about modifying your set of views.

\item
Choose views that will help you to evaluate whether the architecture meets its objectives and that all the ASRs are satisfied. Read the first paragraph of each of the views from the next sections to check whether they suit your needs.
\end{enumerate}

If you're still not sure which views to document, here's a set of tips:

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black, title=TIP]
\hspace*{0.7cm}Try to just pick the most important views, because when there are too many of them, the architecture will become too hard to follow. A good set of views should not only showcase the architecture but also expose the technical risks to the project.
\end{tcolorbox}

There are a few things you should think about when choosing what views you should describe in your documentation. We'll describe them shortly here, but if you're interested, you should grab \textit{Rozanski and Woods'} book mentioned in the \textit{Further reading} section.

\subsubsubsection{3.7.1\hspace{0.2cm}Functional view}

If your software is being developed as part of a bigger system, especially with teams that don't communicate on a daily basis, you should include a functional view (as in the 4+1 model).

One important and often overlooked aspect of documenting your architecture is the definition of the interfaces you provide, despite it being one of the most important things to describe. Whether it's an interface between two of your components or an entry point for the outside world, you should take the time to document it clearly, describing the semantics of objects and calls, as well as usage examples (which you can sometimes reuse as tests).

Another great benefit of including a functional view in your documentation is that it clarifies the responsibilities between components of your system. Each team developing the system should understand where the boundaries are and who's responsible for developing which functionality. All requirements should be explicitly mapped to components to eliminate gaps and duplicated work.

\begin{tcolorbox}[colback=webgreen!5!white,colframe=webgreen!75!black, title=TIP]
\hspace*{0.7cm}An important thing to note here is to avoid overloading your functional view. If it gets messy, no one will want to read it. If you're starting to describe infrastructure on it, consider adding a deployment view. If you end up having a God object in your models, try to rethink the design and split it into smaller, more cohesive pieces.
\end{tcolorbox}

One last important note about the functional view: try to keep each diagram you include on one level of abstraction. On the other hand, don't make it too vague by choosing an overly abstract level; ensure that every element is properly defined and understood by the interested parties.

\subsubsubsection{3.7.2\hspace{0.2cm}Information view}

If your system has non-straightforward needs with regard to information, its processing flow, management process, or storage, perhaps it's a good idea to include this kind of view.

Take the most important, data-rich entities and demonstrate how they flow through the system, who owns them, and who the producers and consumers are. It may be useful to mark how long certain data remains "fresh" and when it can be safely discarded, what the expected latency for it to arrive at certain points of the system is, or how to deal with identifiers if your system works in a distributed environment. If your system manages transactions, this process, along with any rollbacks, should also be clear to your stakeholders. Techniques for transforming, sending, and persisting data can also be important for some of them. If you are operating in the financial domain or have to deal with personal data, you most probably must obey some regulations, so describe how your system plans to tackle this.

The structure of your data can be diagrammed using UML class models. Remember to be clear about the format of your data, especially if it flows between two different systems. NASA lost the \$125 million-worth Mars Climate Orbiter, which it co-developed with Lockheed Martin, because they used different units unknowingly, so keep an eye out for data inconsistencies between systems.

The processing flow of your data can use UML's activity model, and to show the life cycle of information, a state diagram can be used.


\subsubsubsection{3.7.3\hspace{0.2cm}Concurrency view}

If running many concurrent units of execution is an important aspect of your product, consider adding a concurrency view. It can show what issues and bottlenecks you may have (unless that sounds too detailed). Other good reasons to include it are the reliance on interprocess communication, having a non-straightforward task structure, concurrent state management, synchronization, or task failure handling logic.

Use whatever notation you want for this view, as long as it captures the units of execution and their communication. Assign priorities to your processes and threads, if necessary, and then analyze any potential issues, such as deadlocks or contention. You can use state diagrams to show the possible states and their transitions for important units of execution (waiting for queries, executing a query, distributing results, and so on).

If you're not sure about the need to introduce concurrency to your system, a good rule of thumb is \textit{don't}. And if you must, strive for a simple design. Debugging concurrency issues is never easy and always long, so if possible, try to optimize what you have first instead of just throwing more threads at the problem at hand.

If, by looking at your diagram, you're worried about resource contention, try to replace locks on big objects with more locks, but finer-grained, use lightweight synchronization (sometimes atomics are enough), introduce optimistic locking, or reduce what's shared (creating an additional copy of some data in a thread and processing it can be faster than sharing access to the only copy).



\subsubsubsection{3.7.4\hspace{0.2cm}Development view}

If you're building a big system with lots of modules, and you need to structure your code, have system-wide design constraints, or if you want to share some common aspects  between parts of your system, presenting the solution from a development viewpoint should benefit you, along with software developers and testers.

A package diagram of the development view can be handy to show where different modules in your system are located, what their dependencies are, and other related modules (for example, residing in the same software layer). It doesn't need to be a UML diagram â€“ even boxes and lines would do. If you plan for a module to be replaceable, this kind of diagram can show you what other software packages can be affected.

Tactics to increase reuse in your system, such as creating your own runtime framework for components, or tactics for increasing the coherence of your systems, such as a common approach to authentication, logging, internationalization, or other kinds of processing, are all part of the development view. If you see any common parts of the system, document it to be sure that all developers see them too.

A common approach to code organization, building, and configuration management should also go into this section of your documentation. If all this sounds like a lot to document, then focus on the most important parts and cover the rest just briefly, if at all.


\subsubsubsection{3.7.5\hspace{0.2cm}Deployment and operational views}

If you have a non-standard or complex deployment environment, such as specific needs with regard to hardware, third-party software or networking requirements, consider documenting it in a separate deployment section, aimed at system administrators, developers, and testers.

If necessary, cover the following things:

\begin{itemize}
\item
The amount of memory required

\item 
The CPU thread count (with or without hyperthreading)

\item 
Pinning and affinity with regard to NUMA nodes

\item 
Specialist networking equipment requirements, such as switches that mark

\item 
packages to measure latency and throughput in a black-box manner

\item 
The networking topology

\item 
The estimated bandwidth required

\item 
Storage requirements for your app

\item 
Any third-party software that you plan to use
\end{itemize}

Once you have the requirements, you can map them to specific hardware and put them into a runtime platform model. You can use a UML deployment diagram with stereotypes if you desire formal modeling. This should show your processing nodes and client nodes, online and offline storage, network links, specialized hardware, such as firewalls or FPGA or ASIC devices, and a mapping between functional elements and the nodes they'll run on.

If you have non-straightforward networking needs, you can add another diagram showing the networking nodes and the connections between them. 

If you depend on specific technologies (including specific versions of software), it's a good idea to list them to see whether there are any compatibility issues between the software you use. Sometimes, two third-party components will require the same dependency, but in different versions.

If you have a specific installation and upgrade plan in your head, it might be a good idea to write a few words about it. Things such as A/B testing, blue-green deployments, or any particular container magic that your solution will rely on should be clear to everyone involved. Data migration plans should also be covered, if needed, including how long the migration can take and when it could be scheduled.

Any plans for configuration management, performance monitoring, operational monitoring, and control, as well as backup strategies, can all be things worth describing. You'll probably want to create a few groups, identify the dependencies of each, and define the approach for each such group. If you can think about any probable errors that may occur, have a plan to detect and recover from them.

A few notes to the support team can also go into this section: what support is required by which stakeholder group, what classes of incidents you plan to have, how to escalate, and what each level of support will be responsible for.

It's best to engage early with the operational staff and create diagrams specifically for them in order to keep them engaged.

Now that we've discussed how to create documentation about your system and its requirements manually, let's switch to documenting your APIs in an automated manner.








