
由于整体架构的缺点，应运而生了其他方法。一个常见的想法是将解决方案拆分为多个服务，这些服务相互通信。然后，可以将开发工作分配给不同的团队，每个团队负责单独的服务。每个团队的工作界限都很明确，这与整体架构风格完全不同。

\textbf{面向服务架构}，或简称为\textbf{SOA}，其业务功能是模块化的，并作为单独的服务提供给消费者应用使用。每个服务都应有一个自描述的接口，并隐藏实现细节，比如：内部架构、技术或编程语言。这允许多个团队以其感觉舒服的方式开发服务，所以在内部，每个团队都可以使用最适合他们的服务。假如有两个开发团队，一个精通C\#，另一个精通C++，他们可以开发两个可以相互通信的服务。

SOA的倡导者提出了一个宣言，优先考虑以下几点:

\begin{itemize}
\item
业务价值 \textit{高于} 技术策略

\item
战略目标 \textit{高于} 项目效益

\item
内在操作性 \textit{高于} 定制化集成

\item
共享服务 \textit{高于} 目标实现

\item
灵活 \textit{高于} 优化

\item
迭代式演进 \textit{高于} 开始即完美
\end{itemize}

尽管此宣言没有绑定到特定的技术栈、实现或服务类型，但最常见的两种服务类型是SOAP和REST。除了这些，最近还有第三种越来越受欢迎的类型——基于gRPC的。可以在关于面向服务架构和微服务的章节中找到更多相关信息。

\subsubsubsection{2.4.1\hspace{0.2cm}微服务}

顾名思义，微服务是一种软件开发模式，在这种模式中，应用划分为使用轻量级协议进行通信的松耦合服务集合。微服务模式类似于UNIX哲学，即一个程序应该只有一个用途。根据UNIX哲学，高级问题是通过将这些程序组合到UNIX流水线上来解决的。类似地，基于微服务的系统由许多微服务和支持服务组成。

先概述一下这种架构风格的优缺点。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务的利弊}

微服务架构中服务的规模较小，这意味着它们的开发、部署和理解速度更快。由于服务是相互独立构建的，因此编译新版本所需的时间不需要很久。由于这一点，在处理这种架构风格时，使用快速原型和开发会更容易。反过来说，这使得缩短交付时间成为可能，从而可以更快地引入和评估业务需求。

基于微服务的方法的其他一些优点包括:

\begin{itemize}
\item
模块化，这是这种架构风格所固有的。

\item
良好的可测试性。

\item
替换系统部件(例如单个服务、数据库、消息代理或云提供商)时的灵活性。

\item
与遗留系统的集成:不需要迁移整个应用，只需迁移需要开发的部分即可。

\item
支持分布式开发:独立开发团队可以并行地处理多个微服务。

\item
可扩展性:微服务可以独立于其他服务进行伸缩。
\end{itemize}

另一方面，微服务也有一些缺点:

\begin{itemize}
\item	
需要成熟的DevOps方法和对自动化CI/CD的依赖。

\item
更难调试，并且需要更好的监视和分布式跟踪。

\item
额外的开销(就辅助服务而言)可能会抵消较小的应用所带来的好处。

\end{itemize}

现在，了解一下以这种结构风格编写的服务特征。

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务的特点}

由于微服务风格是最近才出现的，所以对微服务没有确定的定义。根据Martin Fowler的说法，微服务有几个基本特征:

\begin{itemize}
\item	
每个服务都应该是可替换和可升级的组件。这与服务之间更容易部署和松耦合相关联，而不是将组件作为单一应用程序中的库。后一种情况下，当替换库时，常常要重新部署整个应用。

\item
每个服务都应该由一个跨职能团队开发，专注于特定的业务功能。听说过康威定律吗？

\begin{flushleft}
\tt
"设计系统的架构受制于产生这些设计的组织的沟通结构。"
\end{flushleft}
\begin{flushright}
\texttt{– Melvyn Conway, 1967}
\end{flushright}

如果没有跨职能的团队，最终会陷入软件孤岛。

\item
每个服务都应该是一个产品，在其生命周期内由开发团队把控，这与项目思维形成了鲜明对比。在项目思维中，你开发软件，然后把它交给别人维护。

\item
服务应该有智能终端，并使用转储管道，而不是反过来。这与传统服务不同，传统服务通常依赖于\textbf{企业服务总线(ESB)}逻辑，通常管理消息的路由，并根据业务规则进行转换。在微服务中，通过将逻辑存储在服务，中并避免与消息传递组件耦合，可以实现内聚。使用“哑”消息队列(如ZeroMQ)有助于实现这一目标。

\item
服务应该以分布式方式进行管理，组织中通常使用一种特定的技术栈编写。当划分为微服务时，每个人都可以选择最适合自己需求的服务。管理并确保每个微服务24/7运行是由负责该特定服务的团队完成的，而非中央部门。亚马逊、Netflix和Facebook等公司遵循这一方法，让开发人员对其服务在生产过程中的完美执行负责，有助于确保产品的高质量。

\item
服务应该以分布式方式管理它们的数据。每个微服务都可以选择适合其需求的数据库，而不是为所有微服务提供统一的数据库。拥有分布式数据可能会给数据更新带来一些挑战，但这样的实现具有更好的扩展性。这就是为什么微服务经常以无事务的方式进行协调，并提供最终结果的一致性。

\item
The infrastructure used by services should be managed automatically. To deal with dozens of microservices in an efficient manner, you need to have Continuous Integration and Continuous Delivery in place, as otherwise, deploying your services will be hell. Automated runs of all your tests will save you lots of time and trouble. Implementing Continuous Deployment on top of that will shorten the feedback loop and allow your customers to use your new features faster, too.

\item
Microservices should be prepared for the failure of other services that they depend on. In a distributed deployment environment with so many moving parts, it's normal for some of them to break from time to time. Your services should be able to handle such failures gracefully. Patterns such as Circuit Breaker or Bulkhead (described later in the book) can help to achieve this. To make your architecture resilient, it's also critical to be able to bring failing services back up efficiently or even to know ahead of time that they're going to crash. Real-time monitoring of latency, throughput, and resource usage is essential for this. Get to know Netflix's Simian Army toolkit as it's invaluable for creating a resilient architecture.

\item
Architectures based on microservices should be ready to constantly evolve. You should design microservices and the cooperation between them in a manner that allows for easy replacement of a single microservice, or sometimes even groups of them. It's tricky to design the services properly, especially since some of the complexity that was once in the code of one bigger module can now be present as complex communication schemes between services, where it's harder to manage – so-called Spaghetti Integration. This means the experience and skill set of the architect plays a more important role than with traditional services or a monolithic approach.


\end{itemize}

On top of that, here are some other characteristics shared by many (but not all) microservices:

\begin{itemize}
\item	
Using separate processes that communicate over network protocols
	
\item
Using technology-agnostic protocols (such as HTTP and JSON)

\item
Keeping services small and with a low runtime overhead
\end{itemize}

Now, you should have a good understanding of what the characteristics of microservicebased systems are, so let's see how this approach compares with other architectural styles.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{微服务和其他架构风格}

Microservices may be used as an architectural pattern on their own. However, they are often combined with other architectural choices, such as cloud-native computing, serverless applications, and mostly with lightweight application containers.

Service-oriented architectures bring loose coupling and high cohesion. Microservices can do it too, when applied correctly. However, it can be somewhat challenging because it requires good intuition to partition the system into the usually vast amount of microservices.

There are more similarities between microservices and their bigger cousins as they, too, can have SOAP-, REST-, or gRPC-based messaging and use technologies such as message queues for being event-driven. They also have well-known patterns to help with achieving the required quality attributes, such as fault tolerance (for example, through the isolation of faulty components), but in order to have an efficient architecture, you must decide on your approach to elements such as API gateways, service registries, load balancing, fault tolerance, monitoring, configuration management, and, of course, the technology stack to use.

\hspace*{\fill} \\ %插入空行
\noindent
\textbf{扩展微服务}

Microservices scale differently to monolithic applications. In monoliths, the entire functionality is handled by a single process. Scaling the application means replicating this process across different machines. Such scaling doesn't take into account which of the functionalities are heavily used and which do not require additional resources.

With microservices, each functional element is handled as a separate service, which means a separate process. In order to scale a microservices-based application, only the parts that require more resources can be replicated to different machines. Such an approach makes it easier to better use the available resources.


\hspace*{\fill} \\ %插入空行
\noindent
\textbf{过渡到微服务}

Most companies have some kind of existing monolithic code that they don't want to immediately rewrite using microservices, but still want to transition to this kind of architecture. In such cases, it's possible to adapt microservices incrementally, by adding more and more services that interact with the monolith. You can create new functionalities as microservices or just cut out some parts of the monolith and create microservices out of them. 

More details regarding microservices, including how to build your own from scratch, are available in Chapter 13, Designing Microservices.













